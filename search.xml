<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 72 Edit Distance 编辑距离]]></title>
    <url>%2F2019%2F06%2F27%2Fdistance%2F</url>
    <content type="text"><![CDATA[LeetCode 72 Edit Distance原题链接 123456789101112131415161718192021222324252627Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.You have the following 3 operations permitted on a word:Insert a characterDelete a characterReplace a characterExample 1:Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)rorse -&gt; rose (remove &apos;r&apos;)rose -&gt; ros (remove &apos;e&apos;)Example 2:Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &apos;t&apos;)inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;)enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;)exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;)exection -&gt; execution (insert &apos;u&apos;) 题目大意，将word1变成word2，最少需要多少步骤。一般碰到这种问题，尽量不要想着用Brute Force的方法去解决，因为如果想通过找出所有可能 的单词，来计算最少步骤数目，时间复杂度是非常高的，因为一个位置可以替换26个字母或者添加或删除一个字母，时间复杂度是指数增长的。所以这 种时候需要通过动态规划来解决这个问题。动态规划的本质是通过一个小的问题来解决较大规模的问题。但是如何找到转移方程，是DP类问题的关键， 也是解决DP问题最难的地方。有的时候知道这个问题需要用DP来解决，但是却无从下手，这种情况非常正常，其实个人认为在LeetCode中最难的一部 分问题就是DP了，只能通过更多的练习来强化。 这个问题是一道Hard的题目，但是代码非常短，像一个easy的题目，但是这其中需要思考的问题很多，以及如何去理解这个题目中DP的意义。先上 代码！ 1234567891011121314class Solution: def minDistance(self, word1: str, word2: str) -&gt; int: dp = [[0 for _ in range(len(word1) + 1)] for _ in range(len(word2) + 1)] for i in range(1, len(dp)): dp[i][0] = i for i in range(1, len(dp[0])): dp[0][i] = i for i in range(1, len(dp)): for j in range(1, len(dp[0])): if word1[j - 1] == word2[i - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1 return dp[-1][-1] 首先构建一个DP的二维矩阵，如果练习的够多可以总结出，要解决对比两个字符串的问题，基本都是可以基于一个二维的DP数组来解决。首先来解释一 下dp[i][j]的含义。dp[i][j]代表的是word1[:j]变成word2[:i]需要多少步，而且dp[i][j]只和dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]有关，也就是说，和最近的三个子问题有关。现在的问题是这三个子问题都代表什么，如何实现通过dp来实现，insert, remove, replace的操作。我简单的通过几个简单的例子来解释。 123456789101112131415remove:word1 = &quot;ab&quot;, word2 = &quot;a&quot;这个可以比较容易的看出，如果想把word1变成word2最快的方法就是将word1末尾的&quot;b&quot;删除掉。dp[i][j] = dp[i][j - 1] + 1dp[i][j - 1]是word1 = &quot;a&quot; word2 = &quot;a&quot;的时候，因为要移除&quot;b&quot;,所以要多一次操作。insert:word1 = &quot;a&quot;, word2 = &quot;ab&quot;这个例子中，需要在word1中添加一个&quot;b&quot;才能和word2一样。dp[i][j] = dp[i - 1][j] + 1replace:word1 = &quot;ab&quot;, word2 = &quot;ac&quot;将word1中的&quot;b&quot;替换成&quot;c&quot;，也就是说需要从两个字符串都是&quot;a&quot;的状态来替换(dp[i - 1][j - 1])dp[i][j] = dp[i - 1][j - 1] + 1 这样如何完成这三种操作的方法已经介绍完了，这道题还有一个要点，就是要初始化dp，因为不初始化dp的话，所有位置的起始状态都是0，这是不对 的，因为我们的最初状态是从两个空的字符串开始的，然后逐渐往后延伸，所以每一个字符串要想变成空字符串的话，也就是当前位置的数字等于当前 字符串的长度。 123456Initialize:dp = [[0 for _ in range(len(word1) + 1)] for _ in range(len(word2) + 1)] for i in range(1, len(dp)): dp[i][0] = i for i in range(1, len(dp[0])): dp[0][i] = i 最后返回dp[-1][-1]就是最小的步数。]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 924 Minimize Malware Spread 最大限度减少恶意软件传播]]></title>
    <url>%2F2019%2F06%2F26%2FSpread%2F</url>
    <content type="text"><![CDATA[LeetCode 924 Minimize Malware Spread原题链接 这道题是LeetCode中属于hard难度的题目，也是一道高频题，个人认为这道题是一道非常典型的题目。题目很长，大概意思就是，有一些节点，其中 一些节点被病毒感染了，某一些节点之间是相互连接的（形成一个图），如果这个图中有一个节点是被病毒感染的，那么整个图都会被感染。要求我们 找到其中一个被感染的节点，并删除他，使所有节点受感染的数目最少。 例子 1234567891011121314151617181920212223Example 1:Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]Output: 00---120和1构成一个图， 2不和任何节点连接，由于0和1同时都被病毒感染，所以按照题目要求我们需要返回一个较小数字的节点。Example 2:Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]Output: 0例子2和例子1其实是类似的。Example 3:Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]Output: 1 0 -- 1 \ / 2这三个节点彼此相互连接， 所以仍然是返回哪个比较小的被感染节点。 其实通过上述三个例子，不是很容易弄明白这个问题。如果在一个图中，有至少有两个以上的节点是被病毒感染的，那么其实无论删除哪个，都不能避 免整个图被感染。所以在扫描整个图时，如果存在这么一个图，图中只有一个节点是被感染的，那么我们如果删除这个节点就可以使这一部分的图，全 变成正常情况。依照这个原则去搜索，即可找出答案。 首先我们需要构造这个图，构图这部分我喜欢写在Union Find的类里面，然后在主函数中进行搜索就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class UnionFind: def __init__(self, graph): self.parent = [i for i in range(len(graph))] self.rank = [1 for _ in range(len(graph))] for i in range(len(graph)): for j in range(i + 1, len(graph[0])): if graph[i][j] == 1 and i != j: self.union(i, j) def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): px, py = self.find(x), self.find(y) if px == py: return if self.rank[px] == self.rank[py]: self.parent[py] = px self.rank[px] += self.rank[py] else: if self.rank[px] &gt; self.rank[py]: self.parent[py] = px self.rank[px] += self.rank[py] else: self.parent[px] = py self.rank[py] += self.rank[px]#上面这个class是UnionFind和图的构造过程，UnionFind在寻找每个节点的父亲节点的平均用时是O（1），所以这个结构对于构造一个图来说是非常高效的。class Solution: def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -&gt; int: uf = UnionFind(graph) dic = collections.defaultdict(list) for i, e in enumerate(uf.parent): dic[e].append(i) #用字典来保存每一个图 res = min(initial) #如果找不到更优的结果，我们需要返回最小值 initial = set(initial) #将病毒节点数组转换成集合，方便搜索（集合中搜索元素的时间复杂度是O（1） mincount = 0 for node in dic: seen = set() for n in dic[node]: if n in initial: seen.add(n) #找出图中所有被感染的节点 if len(seen) == 1: #判断该删除哪个节点 if len(dic[node]) &gt; mincount or (len(dic[node]) == mincount and list(seen)[0] &lt; res): res = list(seen)[0] mincount = len(dic[node]) return res 如果想避免构图这个过程，这道题可以直接用深度优先搜索来求解，深度优先搜索(DFS)的代码更加简洁，但是Union Find的代码看上去更加直观。 1234567891011121314151617181920212223#DFSclass Solution: def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -&gt; int: def dfs(node,vis): for v in range(len(graph[node])): if graph[node][v] == 1 and v not in vis: vis.add(v) dfs(v,vis) seen = set() res = min(initial) initial = set(initial) mincount = 0 for node in range(len(graph)): if node not in seen: vis = set([node]) dfs(node,vis) infect = vis &amp; initial if len(infect) == 1: if len(vis) &gt; mincount or (len(vis) == mincount and list(infect)[0] &lt; res): res = list(infect)[0] mincount = len(vis) seen |= vis return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Union Find</tag>
        <tag>高频</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 215 Kth Largest Element in an Array 排序算法总结]]></title>
    <url>%2F2019%2F06%2F25%2F215%2F</url>
    <content type="text"><![CDATA[LeetCode 215 Kth Largest Element in an Array原题链接 题目大意：从一个未排序的数组中找到第K大的元素。 其实想单纯的解决这个问题真的是非常容易，在Python中一行代码就可以解决。 One - line12def findKthLargest1(self, nums, k): return sorted(nums, reverse = True)[k - 1] 在Python中，sort()方法的时间复杂度是O(nlogn),其实看到第K个元素问题，第一时间想到方法应该是堆排序（Heap Sort), 每一次pop出一个 元素，循环K次即可找到答案。 Heap Sort在这里堆排序可以节省很多时间，但是这里存在着到底是用最大堆(Max heap)还是最小堆(Min Heap)的问题。在Python中，heap模块自动生成的是 最小堆，如果想生成一个最大堆，我们需要将数组中所有的数字取负数，然后重新堆化(Heapify)。那么两者的时间复杂度为 O(n + xlogn), 为什么我这里使用了x， 其实到底是最小堆快还是最大堆快，取决于k到底是靠近数组的开始，还是靠近数组的结尾。如果K在数组的 中间位置，那么两者的时间复杂度其实几乎是一样的。如果K靠近起始位置，那么肯定Min Heap会快，反之亦然。 Min Heap1234567class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: heapq.heapify(nums) res = 0 for _ in range(len(nums) - k + 1): res = heapq.heappop(nums) return res Max Heap12345678class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: heap = [-num for num in nums] heapq.heapify(heap) res = 0 for _ in range(k): res = -heapq.heappop(heap) return res 排序算法(Python 版本)其实这道题考察的是到底该使用那种排序算法，我简单的对几种常用的排序算法进行一下总结。 冒泡排序(Bubble Sort)冒牌排序的本质其实是针对相邻元素，如果第一个元素比第二个元素大，那么交换两者的位置，重复上述的步骤，直到没有可以交换的元素。 平均时间复杂度：O(n ** 2) 最坏时间复杂度：O(n ** 2) 最好时间复杂度：O(n) 空间复杂度： O(1) in-place 123456def BubbleSort(nums): for i in range(1, len(nums)): for j in range(len(nums) - i): if nums[j] &gt; nums[j + 1]: nums[j], nums[j + 1] = nums[j + 1], nums[j] return nums 选择排序(Selection Sort)在未排序数组中找到最大（小）的元素，放在每一轮起始的位置，每一轮结束后，接下来在剩余的数组中继续操作。 平均时间复杂度：O（n ** 2) 最好时间复杂度：O（n ** 2) 最坏时间复杂度：O（n ** 2) 空间复杂度： O（1） in - place 123456789def SelectionSort(nums): for i in range(len(nums) - 1): index = i for j in range(i + 1, len(nums)): if nums[j] &lt; nums[index]: index = j if index != i: nums[index], nums[i] = nums[i], nums[index] return nums 插入排序（Insertion Sort）扫描整个数组，然后针对这个位置上的数字进行操作，如果这个数字比前面的数字小，就一直往前移动，直到整个数组没有可以操作的元素。 平均时间复杂度：O（n ** 2) 最好时间复杂度：O（n) 最坏时间复杂度：O（n ** 2） 空间复杂度： O（1） in - place 123456789def InsertionSort(nums): for i in range(len(nums)): pre = i - 1 cur = nums[i] while pre &gt;= 0 and arr[pre] &gt; cur: arr[pre + 1] = arr[pre] pre -= 1 arr[pre + 1] = cur return nums 希尔排序(Shell Sort)希尔排序法(缩小增量法) 属于插入类排序，是将整个无序列分割成若干小的子序列分别进行插入排序的方法。 平均时间复杂度：O（nlogn) 最好时间复杂度：O（n） 最坏时间复杂度：O（n ** 2） 空间复杂度：O（1）in - place 1234567891011121314def ShellSort(nums): gap = 1 while gap &lt; len(nums) // 2: gap = gap * 3 + 1 while gap &gt; 0: for i in range(gap, len(nums)): temp = nums[i] j = i - gap while j &gt;= 0 and nums[j] &gt; temp: nums[j + gap] = nums[j] j -= gap nums[j + gap] = temp gap = gap // 3 return nums 归并排序(Merge Sort)将一个完整的数组拆分成一些子序列，然后分别针对子序列进行排序，最后在合并到一起，Divide and Conquer的思想。 时间复杂度：O(nlogn) 空间复杂度：O（n） 12345678910111213141516171819202122def MergeSort(nums): if len(nums) &lt; 2: return nums mid = len(nums) // 2 return merge(MergeSort(nums[:mid]), MergeSort(nums[mid:]))def merge(l, r): nums = [] a, b = 0, 0 while a &lt; len(l) and b &lt; len(r): if l[a] &lt; r[b]: nums.append(l[a]) a += 1 else: nums.append(r[b]) b += 1 if a &lt; len(l): nums += l[a:] if b &lt; len(r): nums += r[b:] return nums 快速排序(Quick Sort)找到一个轴，比这个轴大的数字放在一个数组，比轴小的数字放在另一个数组，然后用递归加分而治之对子数组进行相同的操作，最后合并所有子数组。 平均时间复杂度：O（nlogn） 最好时间复杂度：O（nlogn） 最坏时间复杂度：O（n ** 2) 空间复杂度： O（nlogn） 12345678910111213def QuickSort(nums): if len(nums) &lt; 2: return nums else: mid = nums[len(nums) // 2] left = [] right = [] for num in nums: if num &gt; mid: right.append(num) else: left.append(num) return QuickSort(left) + [mid] + QuickSort(right)]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 79, 212 Word Search]]></title>
    <url>%2F2019%2F06%2F24%2FWordSearch%2F</url>
    <content type="text"><![CDATA[LeetCode 79 Word Search原题链接 题目大意：给定一个二维的网格和一个单词，判断单词是否在网格中。 单词必须按照字母顺序，通过相邻的单元格的字母组成，其中相邻指的是4个方向（上，下，左，右），同一个单元格中的单词不能重复使用。 例子12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false. 这道题目，只需要查找一个单词，所以直接暴力求解(bracktrack)就可以。遍历二维网格，找到一个符合要求的开头（单词的首字母），然后以这个 点为起点，进行回溯。 123456789101112131415161718192021222324class Solution: def exist(self, board: List[List[str]], word: str) -&gt; bool: for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == word[0]: if self.dfs(board, i, j, 0, word): return True return False def dfs(self, board, i, j, index, word): if index == len(word): return True if i &lt; 0 or i &gt;= len(board) or j &lt; 0 or j &gt;= len(board[0]) or board[i][j] != word[index]: return False board[i][j] = &apos;#&apos; if self.dfs(board, i - 1, j, index + 1, word): return True if self.dfs(board, i + 1, j, index + 1, word): return True if self.dfs(board, i, j - 1, index + 1, word): return True if self.dfs(board, i , j + 1, index + 1, word): return True board[i][j] = word[index] #LeetCode 212 Word Search II 原题链接12345678910Input: board = [ [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;], [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;], [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;], [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]]words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]Output: [&quot;eat&quot;,&quot;oath&quot;] 这道题其实是Word Search 的升级版，区别在于，前者只要求查找一个单词，后者需要从一个数组中查找每一个单词。我们不可以再像第一题这样直 接进行暴力求解。需要先对整个数组进行预处理。需要使用一个特殊的数据结构叫做字典树（Trie）。在Python中，如果想从一个字典中搜索一个元 素，时间复杂度为O(1),这样可以大大减少我们在搜索中所用的时间。 1&#123;&apos;o&apos;: &#123;&apos;a&apos;: &#123;&apos;t&apos;: &#123;&apos;h&apos;: &#123;&apos;end&apos;: &apos;#&apos;&#125;&#125;&#125;&#125;, &apos;p&apos;: &#123;&apos;e&apos;: &#123;&apos;a&apos;: &#123;&apos;end&apos;: &apos;#&apos;&#125;&#125;&#125;, &apos;e&apos;: &#123;&apos;a&apos;: &#123;&apos;t&apos;: &#123;&apos;end&apos;: &apos;#&apos;&#125;&#125;&#125;, &apos;r&apos;: &#123;&apos;a&apos;: &#123;&apos;i&apos;: &#123;&apos;n&apos;: &#123;&apos;end&apos;: &apos;#&apos;&#125;&#125;&#125;&#125;&#125; 对于整个数组预处理过后，字典树如上图，一定要注意用一个标志（&quot;end&quot;)来表明一个完整单词的结束。否则我们无法确定这是一个完整的单词，还是 一个单词的一部分。 backtrack的过程和上一题的过程累似，只不过需要不断更新root（当前字母作为根节点），然后进行搜索，直到结束。 12345678910111213141516171819202122232425262728class Solution: def findWords(self, board: List[List[str]], words: List[str]) -&gt; List[str]: dic = &#123;&#125; self.res = set() for word in words: node = dic for char in word: if char not in node: node[char] = &#123;&#125; node = node[char] node[&apos;end&apos;] = &apos;#&apos; for i in range(len(board)): for j in range(len(board[0])): self.dfs(dic, board, i, j, &quot;&quot;) return list(self.res) def dfs(self, node, board, i, j, path): if &apos;end&apos; in node: self.res.add(path) if i &lt; 0 or i &gt;= len(board) or j &lt; 0 or j &gt;= len(board[0]) or board[i][j] not in node: return temp = board[i][j] board[i][j] = &apos;#&apos; self.dfs(node[temp], board, i - 1, j, path + temp) self.dfs(node[temp], board, i + 1, j, path + temp) self.dfs(node[temp], board, i, j - 1, path + temp) self.dfs(node[temp], board, i, j + 1, path + temp) board[i][j] = temp]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>BackTrack</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于刷题]]></title>
    <url>%2F2019%2F06%2F23%2FLeetCode%2F</url>
    <content type="text"><![CDATA[LeetCode关于刷题 在现在的大环境下，刷题似乎成为了大部分人的必经之路，越来越多的公司在面试中通过相关题目，来考察求职者。就算已经找到工作的人，也 有很多人每天保持着练习，为了防止自己手生。其实无论到底出于什么目的，刷题真的很重要，当然，刷题不一定能确保你找到一份好的工作，但是 不刷题感觉基本没有设么机会。作为一个转专业的选手（从硬件到软件），这段经历真的是挺痛苦的，刚开始刷题的时候什么都不会，到坚持了6个 月， 刷了900道题，将近4500个submission。这段路真的非常艰辛，但是一定要咬着牙走下去。 看着上面的图，稍微有一点点成就感，但是更多的感觉到一点点忧伤，因为真的感觉好辛苦好累。做这个博客，一个想记录一下自己刷题的生 活，顺便把一些重点的题目的思路重新理一下，并分享给需要的人。我用的是Python（别问， 人生苦短，我用？？？？），以后有机会会试着用 Java写一写。]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
