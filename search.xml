<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode Weekly Contest 143]]></title>
    <url>%2F2019%2F06%2F30%2Fcontest143%2F</url>
    <content type="text"><![CDATA[LeetCode Weekly Contest 143LeetCode 1103 Distribute Candies to People题目链接1234567891011121314151617181920212223242526272829303132333435We distribute some number of candies, to a row of n = num_people people in the following way:We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person.Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person.This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end)until we run out of candies. The last person will receive all of our remaining candies (not necessarily one more than the previous gift).Return an array (of length num_people and sum candies) that represents the final distribution of candies. Example 1:Input: candies = 7, num_people = 4Output: [1,2,3,1]Explanation:On the first turn, ans[0] += 1, and the array is [1,0,0,0].On the second turn, ans[1] += 2, and the array is [1,2,0,0].On the third turn, ans[2] += 3, and the array is [1,2,3,0].On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].Example 2:Input: candies = 10, num_people = 3Output: [5,2,3]Explanation: On the first turn, ans[0] += 1, and the array is [1,0,0].On the second turn, ans[1] += 2, and the array is [1,2,0].On the third turn, ans[2] += 3, and the array is [1,2,3].On the fourth turn, ans[0] += 4, and the final array is [5,2,3]. 题目大意：给每个人分配糖果，从1个糖果开始，每一次分配后，加一个糖果，如果每个人都分配完一轮，还有剩余的，那么从头开始继续分配。 不用多解释，签到题。 123456789101112131415class Solution: def distributeCandies(self, candies: int, num_people: int) -&gt; List[int]: res = [0] * num_people start = 1 i = 0 while start &lt;= candies: res[i] += start candies -= start start += 1 i += 1 if i == len(res): i = 0 if candies: res[i] += candies return res LeetCode 1104 Path In Zigzag Labelled Binary Tree题目链接 123456789101112131415161718In an infinite binary tree where every node has two children, the nodes are labelled in row order.In the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.Given the label of a node in this tree, return the labels in the path from the root of the tree to the node with that label. Example 1:Input: label = 14Output: [1,3,4,14]Example 2:Input: label = 26Output: [1,2,6,10,26] 题目大意：从一个二叉树中找到一个路径，路径的终点是label。需要注意的是这个二叉树按照层序遍历，一行是正序，下一行是逆序的，直到结束。 这道题做的时候出现了重大的失误，感觉没有什么头绪，用了个Brute Force的方法构建一个二叉树，然后用DFS来找这个路径。真的是非常愚蠢了。 结果是超时的，耽误了很多时间。其实这道理有个规律,找到这个规律其实非常简单，当时脑子也是秀逗了。比如在第i层，那么这一层的所有数字都 应该在（2 ** i）到（2 ** （i + 1))这个区间里，我们从下到上来搜索，那么上一层的数字应该是下一层的数字除以2，并且取证，但是由于每一 层之间的顺序是不同的，所以我们只需要找到这个点的对称点即可，重复这些步骤，直到顶层，返回的时候，逆序结果输出就是答案了。 123456789101112131415161718class Solution: def pathInZigZagTree(self, label: int) -&gt; List[int]: level = -1 total = 0 while total &lt; label: level += 1 total += 2 ** level res = [label] level -= 1 cur = label // 2 while level &gt; -1: start, end = 2 ** level, (2 ** (level + 1)) - 1 cur = start + end - cur res.append(cur) cur = cur // 2 level -= 1 return res[::-1] LeetCode 1106 Parsing A Boolean Expression题目链接 123456789101112131415161718192021222324252627282930313233343536Return the result of evaluating a given boolean expression, represented as a string.An expression can either be:&quot;t&quot;, evaluating to True;&quot;f&quot;, evaluating to False;&quot;!(expr)&quot;, evaluating to the logical NOT of the inner expression expr;&quot;&amp;(expr1,expr2,...)&quot;, evaluating to the logical AND of 2 or more inner expressions expr1, expr2, ...;&quot;|(expr1,expr2,...)&quot;, evaluating to the logical OR of 2 or more inner expressions expr1, expr2, ... Example 1:Input: expression = &quot;!(f)&quot;Output: trueExample 2:Input: expression = &quot;|(f,t)&quot;Output: trueExample 3:Input: expression = &quot;&amp;(t,f)&quot;Output: falseExample 4:Input: expression = &quot;|(&amp;(t,f,t),!(t))&quot;Output: false Constraints:1 &lt;= expression.length &lt;= 20000expression[i] consists of characters in &#123;&apos;(&apos;, &apos;)&apos;, &apos;&amp;&apos;, &apos;|&apos;, &apos;!&apos;, &apos;t&apos;, &apos;f&apos;, &apos;,&apos;&#125;.expression is a valid expression representing a boolean, as given in the description. 这个题的意思就是就是返回整个字符串最后的结果，其中包含非，或，与，括号的操作。 这个题作为本子周赛标记为最难的题目，其实也不是很难，主要是要找到正确的方法。其实这个题如果没有括号是不是看上去就简单多了，我们直接 实现题目中这几个基本操作就可以了，但是加上了括号，这里面就存在一定的顺序。我的理解和别人不太一样，我是把这个题目看成计算器类型的题目， 因为在计算器类型的题目中，我们用栈来维护一些括号的操作，和这道题里面的情况是一样的，只不过运算符号，变成了逻辑运算符号。 首先我们需要维护当前的操作符号和字符，通过扫描数组把相对应的字符维护起来，当碰到左括号的时候，需要把左括号之前的字符串和操作符号入栈， 然后把操作符和字符串清零，来维护括号里面的元素。关键点在于碰到右括号的时候，我们需要把之前存入栈的操作符号和字符串pop出来，先pop出来 的是操作符，后pop出来的是字符串，用这个pop出来的操作符来操作当前的字符串，然后把结果添加到之前的字符串中，那么这时候相当于我们把这个 括号给去掉了，所以之前的整个字符串变成了当前字符串，继续重复上述操作。实现AND操作就是当数组中有False的时候出False，其他情况出True。 OR操作是有True出True，其他情况出False。（如果记不清楚的可以回去稍微复习下数字电子电路 - -）。 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def parseBoolExpr(self, expression: str) -&gt; bool: stack = [] string = &quot;&quot; op = &quot;&quot; for char in expression: if char in [&apos;!&apos;, &apos;&amp;&apos;, &apos;|&apos;]: op = char elif char in [&apos;t&apos;, &apos;f&apos;]: string += char elif char == &apos;(&apos;: stack.append(string) stack.append(op) string = &quot;&quot; op = &quot;&quot; elif char == &apos;)&apos;: ops = stack.pop() prestring = stack.pop() if ops == &apos;!&apos;: if string == &apos;t&apos;: prestring += &apos;f&apos; elif string == &apos;f&apos;: prestring += &apos;t&apos; elif ops == &apos;&amp;&apos;: if &apos;f&apos; in string: prestring += &apos;f&apos; else: prestring +=&apos;t&apos; elif ops == &apos;|&apos;: if &apos;t&apos; in string: prestring += &apos;t&apos; else: prestring += &apos;f&apos; string = prestring op = &quot;&quot; else: continue return True if string == &apos;t&apos; else False 计算器类似题目LeetCode 227 Basic Calculator IILeetCode 772 Basic Calculator IIILeetCode 224 Basic Calculator LeetCode 1105 Filling Bookcase Shelves题目链接 1234567891011121314151617181920212223242526272829We have a sequence of books: the i-th book has thickness books[i][0] and height books[i][1].We want to place these books in order onto bookcase shelves that have total width shelf_width.We choose some of the books to place on this shelf (such that the sum of their thickness is &lt;= shelf_width), then build another level of shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.Note again that at each step of the above process, the order of the books we place is the same order as the given sequence of books. For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.Return the minimum possible height that the total bookshelf can be after placing shelves in this manner.Example 1:Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4Output: 6Explanation:The sum of the heights of the 3 shelves are 1 + 3 + 2 = 6.Notice that book number 2 does not have to be on the first shelf. Constraints:1 &lt;= books.length &lt;= 10001 &lt;= books[i][0] &lt;= shelf_width &lt;= 10001 &lt;= books[i][1] &lt;= 1000 题目大意：有一个固定大小的抽屉，问怎么摆放才能使整个高度的值最小。 这道题在周赛的时候没有做出来，第二题耽误了太多的时间实在不应该，但是后来仔细做了一下这道题，感觉确实也没什么思路，其实判断出这个题目 是DP的题目并不难，因为如果把所有的书在不同的位置摆放出来，再计算高度，这个时间复杂度会非常非常的高，但是该怎么处理这个DP问题思考了很 久，DP问题一直是我的薄弱环节，经常摸不着头脑，不知道该怎么下手，确实需要一个针对DP的强化训练了。 简单的说一下思路，维护一个dp数组，dp中的每个位置代表到这个位置时最大的高度，通过扫描books，我们需要判断到底是把这本书继续排放在这一 行，还是说把这本书，连带前面几本书，在宽度限制的范围内一起放到下一行，我们需要得到这一个过程中的找到最小值，其实这就是dp中的转移方程。 1234567891011121314151617class Solution: def minHeightShelves(self, books: List[List[int]], shelf_width: int) -&gt; int: dp = [0] for i, b in enumerate(books): j = i w = shelf_width while j &gt;= 0 and w - books[j][0] &gt;= 0: #这个过程就是找出可以移动多少本书到下一行中。 w -= books[j][0] j -= 1 temp = float(&apos;inf&apos;) for k in range(j + 1, i + 1): #这个双循环就是找出这个过程中的最小值，到底连带几本书到下一行的情况是最佳的。 h = 0 for x in range(k, i + 1): h = max(h, books[x][1]) temp = min(temp, dp[k] + h) dp.append(temp) return dp[-1] 这周周赛总结就到这里，感觉在DP方面急需加强，不够DP也是一个比较难学的部分，里面涉及到模型非常多，急需加油！。]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Biweekly Contest 3 总结]]></title>
    <url>%2F2019%2F06%2F29%2Fbiweekly3%2F</url>
    <content type="text"><![CDATA[LeetCode Biweekly Contest 3LeetCode 1099 Two Sum Less Than K题目链接 12345678910111213141516171819202122232425Given an array A of integers and integer K, return the maximum S such that there exists i &lt; j with A[i] + A[j] = S and S &lt; K. If no i, j exist satisfying this equation, return -1. Example 1:Input: A = [34,23,1,24,75,33,54,8], K = 60Output: 58Explanation: We can use 34 and 24 to sum 58 which is less than 60.Example 2:Input: A = [10,20,30], K = 15Output: -1Explanation: In this case it&apos;s not possible to get a pair sum less that 15. Note:1 &lt;= A.length &lt;= 1001 &lt;= A[i] &lt;= 10001 &lt;= K &lt;= 2000 题目大意：从数组中找两个数字，他们的和必须小于K，求最大的值。（类似于Amazon某一段时间的OA），比较容易算是一个签到题。 看了一下数据 规模，也没想太多，直接Brute Force就通过了。 12345678class Solution: def twoSumLessThanK(self, A: List[int], K: int) -&gt; int: res = -1 for i in range(len(A) - 1): for j in range(i + 1, len(A)): if A[i] + A[j] &lt; K: res = max(res, A[i] + A[j]) return res 比赛结束，重新思考了一下，其实先将数组排序，然后用双指针来操作，会更快一点。 123456789101112class Solution: def twoSumLessThanK(self, A: List[int], K: int) -&gt; int: A.sort() res = -1 l, r = 0, len(A) - 1 while l &lt; r: if A[l] + A[r] &gt;= K: r -= 1 else: res = max(res, A[l] + A[r]) l += 1 return res LeetCode 1100 Find K-Length Substrings With No Repeated Characters题目链接123456789101112131415161718192021222324Given a string S, return the number of substrings of length K with no repeated characters. Example 1:Input: S = &quot;havefunonleetcode&quot;, K = 5Output: 6Explanation: There are 6 substrings they are : &apos;havef&apos;,&apos;avefu&apos;,&apos;vefun&apos;,&apos;efuno&apos;,&apos;etcod&apos;,&apos;tcode&apos;.Example 2:Input: S = &quot;home&quot;, K = 5Output: 0Explanation: Notice K can be larger than the length of S. In this case is not possible to find any substring. Note:1 &lt;= S.length &lt;= 10^4All characters of S are lowercase English letters.1 &lt;= K &lt;= 10^4 题目大意：求一个字符串中有多少个长度为K的子字符串，要求没有重复的元素。 通过一个滑动窗口来扫描整个数组就可以得到答案，时间复杂度O（n) 12345678910111213141516171819class Solution: def numKLenSubstrNoRepeats(self, S: str, K: int) -&gt; int: if len(S) &lt; K: return 0 res = 0 dic = collections.Counter() l, r = 0, 0 while r &lt; len(S): dic[S[r]] += 1 if r - l + 1 &gt; K: dic[S[l]] -= 1 if dic[S[l]] == 0: del dic[S[l]] l += 1 if r - l + 1 == K: if len(dic) == K: res += 1 r += 1 return res LeetCode 1101 The Earliest Moment When Everyone Become Friends题目链接 12345678910111213141516171819202122232425262728293031323334In a social group, there are N people, with unique integer ids from 0 to N-1.We have a list of logs, where each logs[i] = [timestamp, id_A, id_B] contains a non-negative integer timestamp, and the ids of two different people.Each log represents the time in which two different people became friends. Friendship is symmetric: if A is friends with B, then B is friends with A.Let&apos;s say that person A is acquainted with person B if A is friends with B, or A is a friend of someone acquainted with B.Return the earliest time for which every person became acquainted with every other person. Return -1 if there is no such earliest time. Example 1:Input: logs = [[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],[20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]], N = 6Output: 20190301Explanation: The first event occurs at timestamp = 20190101 and after 0 and 1 become friends we have the following friendship groups [0,1], [2], [3], [4], [5].The second event occurs at timestamp = 20190104 and after 3 and 4 become friends we have the following friendship groups [0,1], [2], [3,4], [5].The third event occurs at timestamp = 20190107 and after 2 and 3 become friends we have the following friendship groups [0,1], [2,3,4], [5].The fourth event occurs at timestamp = 20190211 and after 1 and 5 become friends we have the following friendship groups [0,1,5], [2,3,4].The fifth event occurs at timestamp = 20190224 and as 2 and 4 are already friend anything happens.The sixth event occurs at timestamp = 20190301 and after 0 and 3 become friends we have that all become friends. Note:1 &lt;= N &lt;= 1001 &lt;= logs.length &lt;= 10^40 &lt;= logs[i][0] &lt;= 10^90 &lt;= logs[i][1], logs[i][2] &lt;= N - 1It&apos;s guaranteed that all timestamps in logs[i][0] are different.Logs are not necessarily ordered by some criteria.logs[i][1] != logs[i][2] 这个题目看上去很长，简单的来说就是一个朋友圈问题。一个数组里面有一些子数组，每个子数组第一个位置代表时间，第二个和第三个位置代表两个 不同的人。这两个人会在这个时间成为朋友，如果这两个人成为朋友，那么这两个人所处在的朋友圈里的所有人都将成为朋友，要求我们返回最小的时 间，使得所有人成为朋友。 这是一个比较典型的Union Find的问题，把每个人合并到一个圈子里，直到这个圈子包含了所有的人。Union Find的题目其实框架都是一样，在这 道题目中，当我们发现，两个人所处的朋友圈不一样时，我们需要合并这两个朋友圈，合并成功我们要从总人数中减去1，当count等于0的时候，说明 所有人都已经在一个朋友圈里了，这时候直接返回时间即可（需要对数组通过时间进行排序）。 123456789101112131415161718192021222324252627282930313233class Solution: def earliestAcq(self, logs: List[List[int]], N: int) -&gt; int: def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): px, py = find(x), find(y) if px == py: return else: if rank[px] == rank[py]: parent[py] = px rank[px] += rank[py] elif rank[px] &gt; rank[py]: parent[py] = px rank[px] += rank[py] elif rank[px] &lt; rank[py]: parent[px] = py rank[py] += rank[px] self.count -= 1 logs.sort() parent = [i for i in range(N)] rank = [1 for _ in range(N)] self.count = N - 1 res = 0 for log in logs: union(log[1], log[2]) if self.count == 0: return log[0] return -1 LeetCode 1102 Path With Maximum Minimum Value原题链接 1234567891011121314151617181920212223242526272829303132333435Given a matrix of integers A with R rows and C columns, find the maximum score of a path starting at [0,0] and ending at [R-1,C-1].The score of a path is the minimum value in that path. For example, the value of the path 8 → 4 → 5 → 9 is 4.A path moves some number of times from one visited cell to any neighbouring unvisited cell in one of the 4 cardinal directions (north, east, west, south). Example 1:Input: [[5,4,5],[1,2,6],[7,4,6]]Output: 4Explanation: The path with the maximum score is highlighted in yellow. Example 2:Input: [[2,2,1,2,2,2],[1,2,2,2,1,2]]Output: 2Example 3:Input: [[3,4,6,3,4],[0,2,1,1,7],[8,8,3,2,7],[3,2,4,9,8],[4,1,2,0,0],[4,6,5,4,3]]Output: 3 Note:1 &lt;= R, C &lt;= 1000 &lt;= A[i][j] &lt;= 10^9 这道题目不知道为啥通过率为啥这么低，可能好多人和我有一样的误解，大早上可能没睡醒。一开始我以为是找一条路径，从起点到终点，这条路径的 和是最大的，求路径中的最小值。（没仔细读题）看了案例感觉差不多，直接就开始写了，后来发现怎么都无法通过。重新审题，发现其实完全不是这 样。其实就是找一条路径，得到到这个路径中的最小值，使得这个值比其他路径中的最小值要大。 理解清楚后，可能很多人上来都会直接用深度优先搜索(DFS)来解决这个问题，这样做肯定是没问题的，但是在这道题目的数据规模和时间限制下是无 法AC的。粗略计算一下，每个点都有3个不同的方向，时间复杂度大约是O（(r * c) ** 3),时间复杂度非常高。仔细一想可以把这道题简化成找最大 值的问题，先上代码。 class Solution: def maximumMinimumPath(self, A: List[List[int]]) -&gt; int: heap = [(-A[0][0], 0, 0)] dp = [[0 for _ in range(len(A[0]))] for _ in range(len(A))] dp[0][0] = A[0][0] directions = [[1, 0], [-1, 0], [0, 1], [0, -1]] while heap: num, i, j = heapq.heappop(heap) val = -num for d in directions: newi, newj = i + d[0], j + d[1] if 0 &lt;= newi &lt; len(A) and 0 &lt;= newj &lt; len(A[0]): temp = min(val, A[newi][newj]) if temp &gt; dp[newi][newj]: dp[newi][newj] = temp heapq.heappush(heap,(-temp, newi, newj)) return dp[-1][-1] 首先需要建立一个堆数组，和一个dp矩阵，通过维护这个dp矩阵来找最终答案，也是为了优化时间复杂度。dp矩阵中每个元素代表的是不同路径到这个 点的时候，在路径中最小的最大值（好拗口。。）。找最大值这个过程其实就用堆排序来实现就可以，当然在python的自带的堆排序模块中，全部都是 最小堆（在之前的文章中提到过这个问题），要转换成最大堆，我们存入堆的元素需要取负即可。每一次操作如果这个位置的元素值不如dp数组中这个 位置的数值大，我们可以不在将其存入堆中，如果大于这个数字，我们需要将新的数字重新入堆，参与下一次循环。 总结这次的双周周赛感觉还是比较容易，但是自己在一些地方处理的不太好，导致有的地方速度很慢，也跟不熟练有关系，反应很慢。继续努力吧！Fight！]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 239 Sliding Window Maximum 滑动窗口最大值]]></title>
    <url>%2F2019%2F06%2F29%2Fwindow%2F</url>
    <content type="text"><![CDATA[LeetCode 239 Sliding Window Maximum 滑动窗口最大值原题链接 1234567891011121314151617181920Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the veryright. You can only see the k numbers in the window. Each time the sliding window moves right by one position.Return the max sliding window.Example:Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7Note: You may assume k is always valid, 1 ≤ k ≤ input array&apos;s size for non-empty array. 题目大意：给定一个固定size(k)的滑动窗口，当窗口滑动到不同位置时，存储当前窗口内的最大值。 这道题我第一眼看到的时候感觉这道题真的容易，完全不像一个hard的问题，直接上来就建立一个滑动窗口然后开始扫描整个数组，然后记录最大值， 当然了这个做法是没有任何问题的，但是这个问题在LeetCode里的测试案例的数据规模非常小，所以也能AC。 123456789#Brute forceclass Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: if not nums: return [] res = [] for i in range(len(nums) - k + 1): res.append(max(nums[i: i + k])) return res 上述的做法，时间复杂度是O（n * k),因为每次扫描，我们都需对当前窗口来计算最大值是多少，每一次调用max()方法，时间复杂度都是O（k)(窗 口的大小）。假设整个数组的长度非常大，窗口的尺寸也非常大，那么这个时间复杂度其实是O（n ** 2),效率就非常低了，所以我们需要对整个窗口 进行优化。 找最大值或者最小值，其实比较常规的方法就是堆排（Heap Sort），每次找最大值的时候时间复杂度为O(logn),避免每次都要重新扫描窗口。 1234567891011121314151617181920class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: res = [] if not nums: return res window = [] for i in range(k): heapq.heappush(window, -nums[i]) res.append(-window[0]) pop = collections.Counter() for i in range(k, len(nums)): out = nums[i - k] inn = nums[i] pop[out] += 1 heapq.heappush(window, -inn) while pop[-window[0]] &gt; 0: pop[-window[0]] -= 1 heapq.heappop(window) res.append(-window[0]) return res 还有一种更快捷的方法，用队列来解决这个问题，其实这个问题可以简化成维护一个队列，我们只需要知道当前的最大值是多少，还有当前最大值是不 是在这个窗口里，其他的事情其实都不需要考虑，这样一来时间复杂度可以简化到O（n）。 12345678910111213class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: window = collections.deque() res = [] for i, num in enumerate(nums): while window and num &gt; nums[window[-1]]: window.pop() window.append(i) if i &gt;= k - 1: res.append(nums[window[0]]) if i - k + 1 == window[0]: window.popleft() return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>滑动窗口（Sliding Window）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 72 Edit Distance 编辑距离]]></title>
    <url>%2F2019%2F06%2F27%2Fdistance%2F</url>
    <content type="text"><![CDATA[LeetCode 72 Edit Distance原题链接 123456789101112131415161718192021222324252627Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.You have the following 3 operations permitted on a word:Insert a characterDelete a characterReplace a characterExample 1:Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)rorse -&gt; rose (remove &apos;r&apos;)rose -&gt; ros (remove &apos;e&apos;)Example 2:Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &apos;t&apos;)inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;)enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;)exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;)exection -&gt; execution (insert &apos;u&apos;) 题目大意，将word1变成word2，最少需要多少步骤。一般碰到这种问题，尽量不要想着用Brute Force的方法去解决，因为如果想通过找出所有可能 的单词，来计算最少步骤数目，时间复杂度是非常高的，因为一个位置可以替换26个字母或者添加或删除一个字母，时间复杂度是指数增长的。所以这 种时候需要通过动态规划来解决这个问题。动态规划的本质是通过一个小的问题来解决较大规模的问题。但是如何找到转移方程，是DP类问题的关键， 也是解决DP问题最难的地方。有的时候知道这个问题需要用DP来解决，但是却无从下手，这种情况非常正常，其实个人认为在LeetCode中最难的一部 分问题就是DP了，只能通过更多的练习来强化。 这个问题是一道Hard的题目，但是代码非常短，像一个easy的题目，但是这其中需要思考的问题很多，以及如何去理解这个题目中DP的意义。先上 代码！ 1234567891011121314class Solution: def minDistance(self, word1: str, word2: str) -&gt; int: dp = [[0 for _ in range(len(word1) + 1)] for _ in range(len(word2) + 1)] for i in range(1, len(dp)): dp[i][0] = i for i in range(1, len(dp[0])): dp[0][i] = i for i in range(1, len(dp)): for j in range(1, len(dp[0])): if word1[j - 1] == word2[i - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1 return dp[-1][-1] 首先构建一个DP的二维矩阵，如果练习的够多可以总结出，要解决对比两个字符串的问题，基本都是可以基于一个二维的DP数组来解决。首先来解释一 下dp[i][j]的含义。dp[i][j]代表的是word1[:j]变成word2[:i]需要多少步，而且dp[i][j]只和dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]有关，也就是说，和最近的三个子问题有关。现在的问题是这三个子问题都代表什么，如何实现通过dp来实现，insert, remove, replace的操作。我简单的通过几个简单的例子来解释。 123456789101112131415remove:word1 = &quot;ab&quot;, word2 = &quot;a&quot;这个可以比较容易的看出，如果想把word1变成word2最快的方法就是将word1末尾的&quot;b&quot;删除掉。dp[i][j] = dp[i][j - 1] + 1dp[i][j - 1]是word1 = &quot;a&quot; word2 = &quot;a&quot;的时候，因为要移除&quot;b&quot;,所以要多一次操作。insert:word1 = &quot;a&quot;, word2 = &quot;ab&quot;这个例子中，需要在word1中添加一个&quot;b&quot;才能和word2一样。dp[i][j] = dp[i - 1][j] + 1replace:word1 = &quot;ab&quot;, word2 = &quot;ac&quot;将word1中的&quot;b&quot;替换成&quot;c&quot;，也就是说需要从两个字符串都是&quot;a&quot;的状态来替换(dp[i - 1][j - 1])dp[i][j] = dp[i - 1][j - 1] + 1 这样如何完成这三种操作的方法已经介绍完了，这道题还有一个要点，就是要初始化dp，因为不初始化dp的话，所有位置的起始状态都是0，这是不对 的，因为我们的最初状态是从两个空的字符串开始的，然后逐渐往后延伸，所以每一个字符串要想变成空字符串的话，也就是当前位置的数字等于当前 字符串的长度。 123456Initialize:dp = [[0 for _ in range(len(word1) + 1)] for _ in range(len(word2) + 1)] for i in range(1, len(dp)): dp[i][0] = i for i in range(1, len(dp[0])): dp[0][i] = i 最后返回dp[-1][-1]就是最小的步数。]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 924 Minimize Malware Spread 最大限度减少恶意软件传播]]></title>
    <url>%2F2019%2F06%2F26%2FSpread%2F</url>
    <content type="text"><![CDATA[LeetCode 924 Minimize Malware Spread原题链接 这道题是LeetCode中属于hard难度的题目，也是一道高频题，个人认为这道题是一道非常典型的题目。题目很长，大概意思就是，有一些节点，其中 一些节点被病毒感染了，某一些节点之间是相互连接的（形成一个图），如果这个图中有一个节点是被病毒感染的，那么整个图都会被感染。要求我们 找到其中一个被感染的节点，并删除他，使所有节点受感染的数目最少。 例子 1234567891011121314151617181920212223Example 1:Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]Output: 00---120和1构成一个图， 2不和任何节点连接，由于0和1同时都被病毒感染，所以按照题目要求我们需要返回一个较小数字的节点。Example 2:Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]Output: 0例子2和例子1其实是类似的。Example 3:Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]Output: 1 0 -- 1 \ / 2这三个节点彼此相互连接， 所以仍然是返回哪个比较小的被感染节点。 其实通过上述三个例子，不是很容易弄明白这个问题。如果在一个图中，有至少有两个以上的节点是被病毒感染的，那么其实无论删除哪个，都不能避 免整个图被感染。所以在扫描整个图时，如果存在这么一个图，图中只有一个节点是被感染的，那么我们如果删除这个节点就可以使这一部分的图，全 变成正常情况。依照这个原则去搜索，即可找出答案。 首先我们需要构造这个图，构图这部分我喜欢写在Union Find的类里面，然后在主函数中进行搜索就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class UnionFind: def __init__(self, graph): self.parent = [i for i in range(len(graph))] self.rank = [1 for _ in range(len(graph))] for i in range(len(graph)): for j in range(i + 1, len(graph[0])): if graph[i][j] == 1 and i != j: self.union(i, j) def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): px, py = self.find(x), self.find(y) if px == py: return if self.rank[px] == self.rank[py]: self.parent[py] = px self.rank[px] += self.rank[py] else: if self.rank[px] &gt; self.rank[py]: self.parent[py] = px self.rank[px] += self.rank[py] else: self.parent[px] = py self.rank[py] += self.rank[px]#上面这个class是UnionFind和图的构造过程，UnionFind在寻找每个节点的父亲节点的平均用时是O（1），所以这个结构对于构造一个图来说是非常高效的。class Solution: def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -&gt; int: uf = UnionFind(graph) dic = collections.defaultdict(list) for i, e in enumerate(uf.parent): dic[e].append(i) #用字典来保存每一个图 res = min(initial) #如果找不到更优的结果，我们需要返回最小值 initial = set(initial) #将病毒节点数组转换成集合，方便搜索（集合中搜索元素的时间复杂度是O（1） mincount = 0 for node in dic: seen = set() for n in dic[node]: if n in initial: seen.add(n) #找出图中所有被感染的节点 if len(seen) == 1: #判断该删除哪个节点 if len(dic[node]) &gt; mincount or (len(dic[node]) == mincount and list(seen)[0] &lt; res): res = list(seen)[0] mincount = len(dic[node]) return res 如果想避免构图这个过程，这道题可以直接用深度优先搜索来求解，深度优先搜索(DFS)的代码更加简洁，但是Union Find的代码看上去更加直观。 1234567891011121314151617181920212223#DFSclass Solution: def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -&gt; int: def dfs(node,vis): for v in range(len(graph[node])): if graph[node][v] == 1 and v not in vis: vis.add(v) dfs(v,vis) seen = set() res = min(initial) initial = set(initial) mincount = 0 for node in range(len(graph)): if node not in seen: vis = set([node]) dfs(node,vis) infect = vis &amp; initial if len(infect) == 1: if len(vis) &gt; mincount or (len(vis) == mincount and list(infect)[0] &lt; res): res = list(infect)[0] mincount = len(vis) seen |= vis return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>Union Find</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 215 Kth Largest Element in an Array 排序算法总结]]></title>
    <url>%2F2019%2F06%2F25%2F215%2F</url>
    <content type="text"><![CDATA[LeetCode 215 Kth Largest Element in an Array原题链接 题目大意：从一个未排序的数组中找到第K大的元素。 其实想单纯的解决这个问题真的是非常容易，在Python中一行代码就可以解决。 One - line12def findKthLargest1(self, nums, k): return sorted(nums, reverse = True)[k - 1] 在Python中，sort()方法的时间复杂度是O(nlogn),其实看到第K个元素问题，第一时间想到方法应该是堆排序（Heap Sort), 每一次pop出一个 元素，循环K次即可找到答案。 Heap Sort在这里堆排序可以节省很多时间，但是这里存在着到底是用最大堆(Max heap)还是最小堆(Min Heap)的问题。在Python中，heap模块自动生成的是 最小堆，如果想生成一个最大堆，我们需要将数组中所有的数字取负数，然后重新堆化(Heapify)。那么两者的时间复杂度为 O(n + xlogn), 为什么我这里使用了x， 其实到底是最小堆快还是最大堆快，取决于k到底是靠近数组的开始，还是靠近数组的结尾。如果K在数组的 中间位置，那么两者的时间复杂度其实几乎是一样的。如果K靠近起始位置，那么肯定Min Heap会快，反之亦然。 Min Heap1234567class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: heapq.heapify(nums) res = 0 for _ in range(len(nums) - k + 1): res = heapq.heappop(nums) return res Max Heap12345678class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: heap = [-num for num in nums] heapq.heapify(heap) res = 0 for _ in range(k): res = -heapq.heappop(heap) return res 排序算法(Python 版本)其实这道题考察的是到底该使用那种排序算法，我简单的对几种常用的排序算法进行一下总结。 冒泡排序(Bubble Sort)冒牌排序的本质其实是针对相邻元素，如果第一个元素比第二个元素大，那么交换两者的位置，重复上述的步骤，直到没有可以交换的元素。 平均时间复杂度：O(n ** 2) 最坏时间复杂度：O(n ** 2) 最好时间复杂度：O(n) 空间复杂度： O(1) in-place 123456def BubbleSort(nums): for i in range(1, len(nums)): for j in range(len(nums) - i): if nums[j] &gt; nums[j + 1]: nums[j], nums[j + 1] = nums[j + 1], nums[j] return nums 选择排序(Selection Sort)在未排序数组中找到最大（小）的元素，放在每一轮起始的位置，每一轮结束后，接下来在剩余的数组中继续操作。 平均时间复杂度：O（n ** 2) 最好时间复杂度：O（n ** 2) 最坏时间复杂度：O（n ** 2) 空间复杂度： O（1） in - place 123456789def SelectionSort(nums): for i in range(len(nums) - 1): index = i for j in range(i + 1, len(nums)): if nums[j] &lt; nums[index]: index = j if index != i: nums[index], nums[i] = nums[i], nums[index] return nums 插入排序（Insertion Sort）扫描整个数组，然后针对这个位置上的数字进行操作，如果这个数字比前面的数字小，就一直往前移动，直到整个数组没有可以操作的元素。 平均时间复杂度：O（n ** 2) 最好时间复杂度：O（n) 最坏时间复杂度：O（n ** 2） 空间复杂度： O（1） in - place 123456789def InsertionSort(nums): for i in range(len(nums)): pre = i - 1 cur = nums[i] while pre &gt;= 0 and arr[pre] &gt; cur: arr[pre + 1] = arr[pre] pre -= 1 arr[pre + 1] = cur return nums 希尔排序(Shell Sort)希尔排序法(缩小增量法) 属于插入类排序，是将整个无序列分割成若干小的子序列分别进行插入排序的方法。 平均时间复杂度：O（nlogn) 最好时间复杂度：O（n） 最坏时间复杂度：O（n ** 2） 空间复杂度：O（1）in - place 1234567891011121314def ShellSort(nums): gap = 1 while gap &lt; len(nums) // 2: gap = gap * 3 + 1 while gap &gt; 0: for i in range(gap, len(nums)): temp = nums[i] j = i - gap while j &gt;= 0 and nums[j] &gt; temp: nums[j + gap] = nums[j] j -= gap nums[j + gap] = temp gap = gap // 3 return nums 归并排序(Merge Sort)将一个完整的数组拆分成一些子序列，然后分别针对子序列进行排序，最后在合并到一起，Divide and Conquer的思想。 时间复杂度：O(nlogn) 空间复杂度：O（n） 12345678910111213141516171819202122def MergeSort(nums): if len(nums) &lt; 2: return nums mid = len(nums) // 2 return merge(MergeSort(nums[:mid]), MergeSort(nums[mid:]))def merge(l, r): nums = [] a, b = 0, 0 while a &lt; len(l) and b &lt; len(r): if l[a] &lt; r[b]: nums.append(l[a]) a += 1 else: nums.append(r[b]) b += 1 if a &lt; len(l): nums += l[a:] if b &lt; len(r): nums += r[b:] return nums 快速排序(Quick Sort)找到一个轴，比这个轴大的数字放在一个数组，比轴小的数字放在另一个数组，然后用递归加分而治之对子数组进行相同的操作，最后合并所有子数组。 平均时间复杂度：O（nlogn） 最好时间复杂度：O（nlogn） 最坏时间复杂度：O（n ** 2) 空间复杂度： O（nlogn） 12345678910111213def QuickSort(nums): if len(nums) &lt; 2: return nums else: mid = nums[len(nums) // 2] left = [] right = [] for num in nums: if num &gt; mid: right.append(num) else: left.append(num) return QuickSort(left) + [mid] + QuickSort(right)]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 79, 212 Word Search]]></title>
    <url>%2F2019%2F06%2F24%2FWordSearch%2F</url>
    <content type="text"><![CDATA[LeetCode 79 Word Search原题链接 题目大意：给定一个二维的网格和一个单词，判断单词是否在网格中。 单词必须按照字母顺序，通过相邻的单元格的字母组成，其中相邻指的是4个方向（上，下，左，右），同一个单元格中的单词不能重复使用。 例子12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false. 这道题目，只需要查找一个单词，所以直接暴力求解(bracktrack)就可以。遍历二维网格，找到一个符合要求的开头（单词的首字母），然后以这个 点为起点，进行回溯。 123456789101112131415161718192021222324class Solution: def exist(self, board: List[List[str]], word: str) -&gt; bool: for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == word[0]: if self.dfs(board, i, j, 0, word): return True return False def dfs(self, board, i, j, index, word): if index == len(word): return True if i &lt; 0 or i &gt;= len(board) or j &lt; 0 or j &gt;= len(board[0]) or board[i][j] != word[index]: return False board[i][j] = &apos;#&apos; if self.dfs(board, i - 1, j, index + 1, word): return True if self.dfs(board, i + 1, j, index + 1, word): return True if self.dfs(board, i, j - 1, index + 1, word): return True if self.dfs(board, i , j + 1, index + 1, word): return True board[i][j] = word[index] #LeetCode 212 Word Search II 原题链接12345678910Input: board = [ [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;], [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;], [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;], [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]]words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]Output: [&quot;eat&quot;,&quot;oath&quot;] 这道题其实是Word Search 的升级版，区别在于，前者只要求查找一个单词，后者需要从一个数组中查找每一个单词。我们不可以再像第一题这样直 接进行暴力求解。需要先对整个数组进行预处理。需要使用一个特殊的数据结构叫做字典树（Trie）。在Python中，如果想从一个字典中搜索一个元 素，时间复杂度为O(1),这样可以大大减少我们在搜索中所用的时间。 1&#123;&apos;o&apos;: &#123;&apos;a&apos;: &#123;&apos;t&apos;: &#123;&apos;h&apos;: &#123;&apos;end&apos;: &apos;#&apos;&#125;&#125;&#125;&#125;, &apos;p&apos;: &#123;&apos;e&apos;: &#123;&apos;a&apos;: &#123;&apos;end&apos;: &apos;#&apos;&#125;&#125;&#125;, &apos;e&apos;: &#123;&apos;a&apos;: &#123;&apos;t&apos;: &#123;&apos;end&apos;: &apos;#&apos;&#125;&#125;&#125;, &apos;r&apos;: &#123;&apos;a&apos;: &#123;&apos;i&apos;: &#123;&apos;n&apos;: &#123;&apos;end&apos;: &apos;#&apos;&#125;&#125;&#125;&#125;&#125; 对于整个数组预处理过后，字典树如上图，一定要注意用一个标志（&quot;end&quot;)来表明一个完整单词的结束。否则我们无法确定这是一个完整的单词，还是 一个单词的一部分。 backtrack的过程和上一题的过程累似，只不过需要不断更新root（当前字母作为根节点），然后进行搜索，直到结束。 12345678910111213141516171819202122232425262728class Solution: def findWords(self, board: List[List[str]], words: List[str]) -&gt; List[str]: dic = &#123;&#125; self.res = set() for word in words: node = dic for char in word: if char not in node: node[char] = &#123;&#125; node = node[char] node[&apos;end&apos;] = &apos;#&apos; for i in range(len(board)): for j in range(len(board[0])): self.dfs(dic, board, i, j, &quot;&quot;) return list(self.res) def dfs(self, node, board, i, j, path): if &apos;end&apos; in node: self.res.add(path) if i &lt; 0 or i &gt;= len(board) or j &lt; 0 or j &gt;= len(board[0]) or board[i][j] not in node: return temp = board[i][j] board[i][j] = &apos;#&apos; self.dfs(node[temp], board, i - 1, j, path + temp) self.dfs(node[temp], board, i + 1, j, path + temp) self.dfs(node[temp], board, i, j - 1, path + temp) self.dfs(node[temp], board, i, j + 1, path + temp) board[i][j] = temp]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>BackTrack</tag>
        <tag>Trie</tag>
        <tag>高频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于刷题]]></title>
    <url>%2F2019%2F06%2F23%2FLeetCode%2F</url>
    <content type="text"><![CDATA[LeetCode关于刷题 在现在的大环境下，刷题似乎成为了大部分人的必经之路，越来越多的公司在面试中通过相关题目，来考察求职者。就算已经找到工作的人，也 有很多人每天保持着练习，为了防止自己手生。其实无论到底出于什么目的，刷题真的很重要，当然，刷题不一定能确保你找到一份好的工作，但是 不刷题感觉基本没有设么机会。作为一个转专业的选手（从硬件到软件），这段经历真的是挺痛苦的，刚开始刷题的时候什么都不会，到坚持了6个 月， 刷了900道题，将近4500个submission。这段路真的非常艰辛，但是一定要咬着牙走下去。 看着上面的图，稍微有一点点成就感，但是更多的感觉到一点点忧伤，因为真的感觉好辛苦好累。做这个博客，一个想记录一下自己刷题的生 活，顺便把一些重点的题目的思路重新理一下，并分享给需要的人。我用的是Python（别问， 人生苦短，我用？？？？），以后有机会会试着用 Java写一写。]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
