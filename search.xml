<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode Biweekly Contest 4 总结]]></title>
    <url>%2F2019%2F07%2F13%2Fbiweekly4%2F</url>
    <content type="text"><![CDATA[LeetCode 1118 Number of Days in a Month123456789101112131415161718192021222324Given a year Y and a month M, return how many days there are in that month. Example 1:Input: Y = 1992, M = 7Output: 31Example 2:Input: Y = 2000, M = 2Output: 29Example 3:Input: Y = 1900, M = 2Output: 28 Note:1583 &lt;= Y &lt;= 21001 &lt;= M &lt;= 12 日常签到题，分别判断是不是闰年，然后判断月份，返回当前月中有多少天。 12345678910111213class Solution: def numberOfDays(self, Y: int, M: int) -&gt; int: if M in [1, 3, 5, 7, 8, 10, 12]: return 31 elif M in [4, 6, 9, 11]: return 30 elif M == 2: if Y % 400 == 0: return 29 elif Y % 4 == 0 and Y % 100 != 0: return 29 else: return 28 LeetCode 1119 Remove Vowels from a String12345678910111213141516171819Given a string S, remove the vowels &apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, and &apos;u&apos; from it, and return the new string. Example 1:Input: &quot;leetcodeisacommunityforcoders&quot;Output: &quot;ltcdscmmntyfrcdrs&quot;Example 2:Input: &quot;aeiou&quot;Output: &quot;&quot; Note:S consists of lowercase English letters only.1 &lt;= S.length &lt;= 1000 也是个签到题，扫描字符串，如果是元音字符就忽略，不是的保存下来，返回新的字符串。 1234567class Solution: def removeVowels(self, S: str) -&gt; str: res = &quot;&quot; for char in S: if char not in [&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;]: res += char return res LeetCode 1120 Maximum Average Subtree12345678910111213141516Given the root of a binary tree, find the maximum average value of any subtree of that tree.(A subtree of a tree is any node of that tree plus all its descendants. The average value of a tree is the sum of its values, divided by the number of nodes.) Example 1:Input: [5,6,1]Output: 6.00000Explanation: For the node with value = 5 we have and average of (5 + 6 + 1) / 3 = 4.For the node with value = 6 we have and average of 6 / 1 = 6.For the node with value = 1 we have and average of 1 / 1 = 1.So the answer is 6 which is the maximum. 题目大意：求一个二叉树中，最大平均值的子树。递归扫描二叉树，每到一个节点判断一次数值大小即可。 1234567891011121314151617181920# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def maximumAverageSubtree(self, root: TreeNode) -&gt; float: self.res = 0 def helper(node, count): if not node: return 0, 0 else: l = helper(node.left, count) r = helper(node.right, count) self.res = max(self.res, (l[0] + r[0] + node.val) / (1 + l[1] + r[1])) return l[0] + r[0] + node.val, 1 + l[1] + r[1] helper(root, 0) return float(&apos;%.5f&apos;%self.res) LeetCode 1121 Divide Array Into Increasing Sequences123456789101112131415161718192021222324Given a non-decreasing array of positive integers nums and an integer K, find out if this array can be divided into one or more disjoint increasing subsequences of length at least K. Example 1:Input: nums = [1,2,2,3,3,4,4], K = 3Output: trueExplanation: The array can be divided into the two subsequences [1,2,3,4] and [2,3,4] with lengths at least 3 each.Example 2:Input: nums = [5,6,6,7,8], K = 3Output: falseExplanation: There is no way to divide the array using the conditions required. Note:1 &lt;= nums.length &lt;= 10^51 &lt;= K &lt;= nums.length1 &lt;= nums[i] &lt;= 10^5 题目大意：一个有序递增的数组，判断这个数组是否可以分组，要求每一组至少有K个元素，而且每一组都要求有序递增的。我一看是个hard题目，还 想着用DP来做- -但是感觉有点复杂。考虑了一会儿发现其实这个问题，我们只需要得出最多可以分多少个组，然后原数组中的元素出现最多的次数是否 小于等于分组的数目即可。有点脑筋急转弯的意思。 123class Solution: def canDivideIntoSubsequences(self, nums: List[int], K: int) -&gt; bool: return max(collections.Counter(nums).values()) &lt;= len(nums) // K]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 315, 493 Binary Indexed Tree]]></title>
    <url>%2F2019%2F07%2F12%2Fbit%2F</url>
    <content type="text"><![CDATA[这篇主要想记录一下BIT系列的问题（Binary Indexed Tree),这个是一个比较巧妙的数据结构，虽然不是很常见，但是针对一些特殊问题，有着非 常好的效果，如果单纯的凭借文字叙述可能不太好描述这个数据结构，推荐下列一个视频。 视频链接 如果想更清楚的了解整个BIT的运算过程，可以去尝试下面这个网站，可以自己亲手操作。 网页链接 LeetCode 315 Count of Smaller Numbers After Self原题链接 123456789101112You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].Example:Input: [5,2,6,1]Output: [2,1,1,0] Explanation:To the right of 5 there are 2 smaller elements (2 and 1).To the right of 2 there is only 1 smaller element (1).To the right of 6 there is 1 smaller element (1).To the right of 1 there is 0 smaller element. 题目大意：给出一个数组，里面的元素全是数字，要求返回一个数组。需要求出每一个元素右边有多少个元素比当前的元素小。 Brute Force的方法可能比较直接，分别针对每一个元素扫描其右边的所有元素，得出结果。但是这样的做法是非常不效率的，因为每一次扫描的过程 中，都包含着非常多重复的过程，时间复杂度大约是N的阶乘，显然如果数据规模非常大，这样的做法是不可取的。如果用BIT来解决这个问题，时间 复杂度为nlogn。简单说一下过程，首先将数组排序，用一个rank字典来存储数组中每一个元素，每个元素对应的是这个元素在数组中的大小位置，方 便后面BIT的操作。然后逆序扫描整个数组，用扫描到当前元素的rank来查找BIT，求出当前BIT中有多少比这个元素的rank大的元素。然后把当前扫 描的元素更新到BIT中。具体BIT的运作原理，建议认真去看一下上述的链接，我认为是讲解BIT最好的视频！ 123456789101112131415161718192021class Solution: def countSmaller(self, nums: List[int]) -&gt; List[int]: rank = &#123;&#125; for i, num in enumerate(sorted(nums)): rank[num] = i + 1 bit = [0] * (len(nums) + 1) def update(i): while i &lt; len(bit): bit[i] += 1 i += (i &amp; -i) def query(i): res = 0 while i: res += bit[i] i -= (i &amp; -i) return res res = [] for num in reversed(nums): res.append(query(rank[num] - 1)) update(rank[num]) return res[::-1] LeetCode 493 Reverse Pairs原题链接 123456789101112131415Given an array nums, we call (i, j) an important reverse pair if i &lt; j and nums[i] &gt; 2*nums[j].You need to return the number of important reverse pairs in the given array.Example1:Input: [1,3,2,3,1]Output: 2Example2:Input: [2,4,3,5,1]Output: 3Note:The length of the given array will not exceed 50,000.All the numbers in the input array are in the range of 32-bit integer. 题目大意：虽然这个题目叫reverse pairs，但是本质上和上面的题类似，唯一的变化就是在小的基础上，左边的数字要比右边的数字的2倍要大， 而且如果是负数，操作起来会有点复杂。但是大致上的操作过程和上一题是一样的。 首先需要对数组进行预处理，将原数组中所有元素的值乘以2加入到数组中，然后针对现在所有的元素进行分级，和上题一样存入rank中，方便后续 BIT的操作，针对bit查询的时候，我们根据当前扫描的元素的rank - 1的位置来查询，更新的时候我们在这个数字乘以2的rank位置进行更新，这样 做的目的主要是为了处理负数。 123456789101112131415161718192021222324class Solution: def reversePairs(self, nums: List[int]) -&gt; int: if not nums: return 0 def update(i): while i &lt; len(bit): bit[i] += 1 i += (i &amp; -i) def query(i): res = 0 while i: res += bit[i] i -= (i &amp; -i) return res rank = &#123;&#125; newnum = nums + [x * 2 for x in nums] for i, n in enumerate(sorted(list(set(newnum)))): rank[n] = i + 1 bit = [0] * (len(set(newnum)) + 1) res = 0 for n in nums[::-1]: res += query(rank[n] - 1) update(rank[n * 2]) return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Binary Indexed Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 407,417 BFS(广度优先搜索)类问题]]></title>
    <url>%2F2019%2F07%2F09%2F407-417%2F</url>
    <content type="text"><![CDATA[LeetCode 407 Trapping Rain Water II原题链接 123456789101112131415161718192021Given an m x n matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining. Note:Both m and n are less than 110. The height of each unit cell is greater than 0 and is less than 20,000. Example:Given the following 3x6 height map:[ [1,4,3,1,3,2], [3,2,1,3,2,4], [2,3,3,2,3,1]]Return 4. 题目大意：这道题其实和Trapping Rain Water II很像，只不过现在的问题题比之前的问题高了一个维度，还是求这个物体总共能接收多少雨。 在前面的问题中我们是用双指针的方法来解决的，这道题其实也可以用双指针的方法来解决，不过这个双指针怎么来运作比较难想。换一个角度，一个 立体的模型，如果希望他能接住物体，那么一定在内部的某一些位置存在一些凹形的模型，那么我们只要找到这个凹形就可以了。那么怎么来进行操作， 这里就涉及到一个算法叫做BFS（广度优先搜索）。我们要找到内部存在的凹形模型，我们就需要从整个模型的最外层入手，一点一点的往内部搜索，来 判断是否存在这个凹形就可以了。我们用一个栈来维护最外层的所有点，然后每一次pop出一个最低的点，因为能盛多少水，取决于周围最低的那个板。 这里找最小值，可以使用堆排序来完成，来优化搜索。然后找到新的点，并且这个点没有被扫描过，将其入堆，然后进行下一轮的搜索，直到扫描完所 有的位置。 12345678910111213141516171819202122class Solution: def trapRainWater(self, heightMap: List[List[int]]) -&gt; int: if not heightMap or not heightMap[0]: return 0 heap = [] seen = set() for i in range(len(heightMap)): #这个双循环是为了将整个模型的最边上的所有点扫描入堆。 for j in range(len(heightMap[0])): if i == 0 or j == 0 or i == len(heightMap) - 1 or j == len(heightMap[0]) - 1: heapq.heappush(heap, (heightMap[i][j], i, j)) seen.add((i, j)) res = 0 directions = [[1, 0], [-1, 0], [0, 1], [0, -1]] while heap: #BFS部分 height, i, j = heapq.heappop(heap) for d in directions: newi, newj = i + d[0], j + d[1] if 0 &lt;= newi &lt; len(heightMap) and 0 &lt;= newj &lt; len(heightMap[0]) and (newi, newj) not in seen: res += max(0, height - heightMap[newi][newj]) heapq.heappush(heap, (max(height, heightMap[newi][newj]), newi, newj)) # 新入堆的位置的高度，一定是两个点比较后的最高位置。 seen.add((newi, newj)) return res LeetCode 417 Pacific Atlantic Water Flow原题链接 12345678910111213141516171819202122232425262728Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the &quot;Pacific ocean&quot; touches the left and top edges of the matrix and the &quot;Atlantic ocean&quot; touches the right and bottom edges.Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.Note:The order of returned grid coordinates does not matter.Both m and n are less than 150. Example:Given the following 5x5 matrix: Pacific ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) * ~ 3 2 3 (4) (4) * ~ 2 4 (5) 3 1 * ~ (6) (7) 1 4 5 * ~ (5) 1 1 2 4 * * * * * * AtlanticReturn:[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix). 这道题目和407其实很像，407是找中间的最低位置，这道题是找中间的最高位置。简单描述下题目，一个矩阵，矩阵中的每个点的值都代表是当前位置 的海拔高度，左上角是太平洋，右下角是大西洋，要求我们找到所有点，其中每个点的谁可以流向两个海洋。这道题的做法和407几乎一样，从边上往 中心进行BFS，最后找到两个BFS结果的并集就可以了。 12345678910111213141516171819202122232425class Solution: def pacificAtlantic(self, matrix: List[List[int]]) -&gt; List[List[int]]: if not matrix: return [] p = set() a = set() for i in range(len(matrix[0])): p.add((0, i)) a.add((len(matrix) - 1, i)) for i in range(len(matrix)): p.add((i, 0)) a.add((i, len(matrix[0]) - 1)) def bfs(seen): queue = collections.deque(seen) directions = [[1, 0], [-1, 0], [0, 1], [0, -1]] while queue: i, j = queue.popleft() for d in directions: newi, newj = i + d[0], j + d[1] if 0 &lt;= newi &lt; len(matrix) and 0 &lt;= newj &lt; len(matrix[0]) and (newi, newj) not in seen and matrix[newi][newj] &gt;= matrix[i][j]: queue.append((newi, newj)) seen.add((newi, newj)) return seen return list(bfs(p) &amp; bfs(a)) 需要分别对两个海洋进行BFS，因为每次的起点不同，找到两个海洋中的最高位置，看看这些最高位置有没有重合的部分，这些部分就是我们需要找的点。]]></content>
      <categories>
        <category>高频</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 84，85，42 最大矩形系列问题]]></title>
    <url>%2F2019%2F07%2F08%2FLargestRectangle%2F</url>
    <content type="text"><![CDATA[今天总结几道用栈来解决最大面积问题，也算是高频题，面试中经常出现。 LeetCode 84 Largest Rectangle in Histogram原题链接 题目大意：通过扫描矩阵，找出由几个不同的矩形所构成的矩形面积的最大值。 如果由几个不同的矩形构成一个矩形，假设他们在同一水平线，那么这个矩形的高度应该由最低的那个矩形决定，然后构成的这个矩形是否是面积最大， 这还不一定，需要继续扫描其他的矩形来判断，其实这就是这个栈的思想，这道题里面用的是递增栈。我们用一个栈来维护扫描过的矩形，如果当前扫描 的这个矩形高于栈尾的矩形，那么不进行任何操作，直接入栈。如果当前的矩形小于那么我们需要进行退栈，pop出一个矩形，那么这个矩形的宽度， 应该是从当前扫描的位置，到现在栈尾的位置，一直扫描到数组结束即可。虽然是一道hard的题，但是比较好想，通过代码来分析。 123456789101112class Solution: def largestRectangleArea(self, heights: List[int]) -&gt; int: stack = [] res = 0 #维护这个最大值 heights.append(0) for i, h in enumerate(heights): while stack and h &lt; heights[stack[-1]]: #持续退栈来找出当前比较高的矩形，来寻找当前这个高度的矩形最大面积。 index = stack.pop() w = i if not stack else i - stack[-1] - 1 res = max(res, heights[index] * w) stack.append(i) return res LeetCode 85 Maximal Rectangle原题链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445Given a 2D binary matrix filled with 0&apos;s and 1&apos;s, find the largest rectangle containing only 1&apos;s and return its area.Example:Input:[ [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]Output: 6``` 这道题目相比上一道题目稍微难想，因为上一个题，每一个相同的index位置的矩形都是连续的，然而这道题是以一个2D矩阵来表示的，这其中同一个 位置的矩形中间可能是断开的，所以单纯的使用上一道题的方法是行不通的。我们可以通过一层一层的扫描这个矩阵，来确保每一个位置的矩形都是连 续的，然后针对当前的层数进行扫描得出结果，这就很巧妙的转换成上一题的做法。 ```angular2class Solution: def maximalRectangle(self, matrix: List[List[str]]) -&gt; int: if not matrix or not matrix[0]: return 0 res = 0 height = [0] * len(matrix[0]) for i in range(len(matrix)): #一层一层的扫描将数据传入height中 for j in range(len(matrix[0])): if matrix[i][j] == &apos;1&apos;: #如果矩阵当前位置等于1，那么说明到这个位置和上一层的矩形是相连接的，所以高度需要加1. height[j] += 1 else: #如果矩阵当前位置等于0，说明到这一层这个位置的矩形断开了，我们需要将height中这个位置归0. height[j] = 0 res = max(res, self.check(height)) #每一层扫描结束，我们需要对到这一层为止的height，进行和上一题同样的递增栈处理。 return res def check(self, height): #辅助函数，功能和上一题一样。 height = height + [0] stack = [] res = 0 for i, h in enumerate(height): while stack and h &lt; height[stack[-1]]: index = stack.pop() w = i if not stack else i - stack[-1] - 1 res = max(res, height[index] * w) stack.append(i) return res LeetCode 42 Trapping Rain Water原题链接 1234567891011Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!Example:Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 这道题是一道高频题，各大公司都有用过这道题目，大概意思就是图中不同位置有不同高度的矩形，会存在高低不同导致一些坑的形成，当下雨时，这 个系统能接住多少雨水。这道题目看上去有些复杂，实际是就是把之前的问题反过来想。只有形成凹的形状时才能保存雨水，所以我们这里需要运用递 减栈，通过扫描整个数组来维护这个递减栈，如果发现栈尾的矩形高度比当前低，说明形成洼地了，可以接住雨水，这时候计算出高度差和高度即可。 这个过程其实类似于一层一层的存水。 123456789101112131415class Solution: def trap(self, height: List[int]) -&gt; int: stack = [] res = 0 for i, h in enumerate(height): while stack and h &gt; height[stack[-1]]: #当前的高度大于栈尾的高度，那么说明栈尾的矩形是当前这一块位置的最低点。 index = stack.pop() if not stack: break hei = min(h, height[stack[-1]]) width = i - stack[-1] - 1 #将矩形pop出来后，当前栈尾的位置到当前扫描的位置是宽度。 res += (hei - height[index]) * width # 需要计算出pop出的矩形两边的高度，哪一边矮，那么这就是高度。 stack.append(i) return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>FaceBook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 753 Cracking the Safe]]></title>
    <url>%2F2019%2F07%2F07%2F753crackingthesafe%2F</url>
    <content type="text"><![CDATA[LeetCode 753 Cracking the Safe原题链接1234567891011121314151617181920212223There is a box protected by a password. The password is a sequence of n digits where each digit can be one of the first k digits 0, 1, ..., k-1.While entering a password, the last n digits entered will automatically be matched against the correct password.For example, assuming the correct password is &quot;345&quot;, if you type &quot;012345&quot;, the box will open because the correct password matches the suffix of the entered password.Return any password of minimum length that is guaranteed to open the box at some point of entering it. Example 1:Input: n = 1, k = 2Output: &quot;01&quot;Note: &quot;10&quot; will be accepted too.Example 2:Input: n = 2, k = 2Output: &quot;00110&quot;Note: &quot;01100&quot;, &quot;10011&quot;, &quot;11001&quot; will be accepted too. 题目大意：类似一个破解密码的系统，这个系统很有意思，我们可以一直输入一串密码，如果在输入过程中有一部分和指定密码完全重合，那么这个 密码就被破解了。要求我们构造一个最短的字符串，里面需要包含所有可能的密码。 其实这个早就被前人证明过了，叫做De Bruijin sequence问题，反正具体怎么证明的我是智商有限，有兴趣的可以去wiki上去看一下，我先上一份 LeetCode disscusion 区的一份代码，非常的简洁，先来分析一下。 1234567891011121314151617class Solution(object): def crackSafe(self, n, k): &quot;&quot;&quot; :type n: int :type k: int :rtype: str &quot;&quot;&quot; ans = &quot;0&quot; * (n - 1) visits = set() for x in range(k ** n): current = ans[-n+1:] if n &gt; 1 else &apos;&apos; for y in range(k - 1, -1, -1): if current + str(y) not in visits: visits.add(current + str(y)) ans += str(y) break return ans 源码链接 简单分析一下这个代码，首先初始化一个答案的前缀(&apos;0&apos; * (n - 1)),通过循环每一次往前缀后面添加一个数字，如果这个数字和前缀组成的一个新 的密码，我们没有处理过（不在visits）中，那么我们更新当前的总字符串，然后持续更新。需要循环k ** n次，这个次数是所有的密码总数。最后 返回答案即可。 当时看到这个代码的时候我没有进行特别深刻的分析，但是看到网上有网友说，他在Google onsite的时候问到这么一个问题，他当时写这个代码的 时候虽然是完全可以通过的，但是被面试官问了好多关于证明的问题。然后我回过头来仔细分析了一下这个代码，里面确实存在很多不确定或者无法分 析的地方，但是在LeetCode中这个代码完全可以通过。 第一点，为什么循环k ** n次一定能找到这个答案。第二点是我自己写的时候发现的问题，为什么在current后面添加新的元素的时候，一定要倒序 遍历k范围内的值，我自己写的时候是正序遍历，但是答案是错的。我在网上搜索了很多关于这个答案的做法，大部分的文章，大部分感觉都特别敷衍， 代码和上述代码类似，但是完全解释不清楚。其实面试的时候写出这种代码被问住了会特别特别尴尬。 花花的讲解 这个讲解分析的就特别清楚，如果有兴趣可以参考。 我自己写了一个代码，看上去接近Brute Force，但是却通过了所有的Test case。先看代码。 1234567891011121314151617181920212223class Solution: def crackSafe(self, n: int, k: int) -&gt; str: self.total = k ** n self.res = &apos;0&apos; * n self.seen = set() self.seen.add(self.res) self.dfs(n, k) return self.res def dfs(self, n, k): if len(self.seen) == self.total: return True cur = self.res[len(self.res) - n + 1:] for i in range(k): cur = cur + str(i) if cur not in self.seen: self.seen.add(cur) self.res += str(i) if self.dfs(n, k): return True self.seen.remove(cur) self.res = self.res[:-1] cur = cur[:-1] 这个代码的思路是通过backtrack去进行深度搜索，直到完成搜索时，密码的数量等于总数的时候，在返回总的字符串，其他的时候回溯，继续进行 深度搜索。看上去这样的解法看上去递归深度会非常非常高，实际上这个解法的运行时间只比线性时间慢一点点，这中间省略了很多的回溯过程，这可 能跟De Bruijin sequence的证明有关系，不过没关系这个代码的过程涵盖了所有可能的过程。]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Hard</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习]]></title>
    <url>%2F2019%2F07%2F05%2Fpython%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Python 语言特性该环节涉及到一些比较细小琐碎的东西，看上去不是很起眼，但是被问到还是很容易出问题。 Python 函数参数传递1234567891011121314example 1:a = 1def fun(a): a = 2fun(a)print(a)example 2:a = []def fun(a): a.append(1)print(a) 首先看第一个例子，我们首先我们给a赋值1，然后通过fun函数来改变a的值，那么运行这个函数之后，a是应该等于1还是等于2？ 第二个例子中，a是一个空的list，通过运行函数，往a中添加1，那么a最后应该变成什么样子？ 在Python中通过传递函数来更改对象a（这个a不是变量，如果是变量那么是可以随意改变的），对象有两种类型，一种是可变对象（mutable）一种 是不可变的对象（immuable）。在Python中不可变对象有：strings，tuple，numbers，可变对象有：list，dict，set。所以第一个例子中a不 会发生任何变化，例子2中的啊变成[1]。 Python methodsPython中有3个方法，静态方法（staticmethon），类方法（classmethod）和实例方法。 123456789def fun(x): print(&quot;Hello World&quot; * x) class A: def fun(self, x): print(&quot;Hello World&quot; * x) def class_fum(cls, x): print(&quot;Hello World&quot; * x)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 329,741]]></title>
    <url>%2F2019%2F07%2F05%2Fcherrypick%2F</url>
    <content type="text"><![CDATA[今天来做一下两道DP的题目，这两道题目都是用记忆化递归来解决，所以就放在一起了。强化DP思想！ LeetCode 329 Longest Increasing Path in a Matrix原题链接 1234567891011121314151617181920212223242526Given an integer matrix, find the length of the longest increasing path.From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).Example 1:Input: nums = [ [9,9,4], [6,6,8], [2,1,1]] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9].Example 2:Input: nums = [ [3,4,5], [3,2,6], [2,2,1]] Output: 4 Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed. 题目大意：在二维矩阵中找到最长递增路径，返回路径长度即可。 这道题明显是一道dp的题目，如果用Brute Force的方法，时间复杂度会非常高，大约是O(2 ** mn),所以说一定是用dp来解决了。 简单说一下思想，比如我们想确定矩阵中某一个点可以构成的最长递增路径，我们需要知道他4个相邻位置的结果，然后判断到当前位置是不是递增的 即可，那么这个过程其实就是一个递归的过程（bottom-up）。但是递归的过程中存在着很多重复的过程，如果不去避免重复的递归，那么其实就和 Brute Force的方法没什么区别了，所以这里需要使用记忆化（memoization）来存储每一个状态的值，当递归时候，处理到已经处理过的部分， 我们直接调用这个状态的值就可以了。可以使用字典来存储各个状态下的值，也方便搜索，因为从字典中找一个key的时间复杂度是线性的。 1234567891011121314151617181920class Solution: def longestIncreasingPath(self, matrix: List[List[int]]) -&gt; int: self.dic = collections.defaultdict(int) self.res = 0 def dfs(i, j, pre): if i &lt; 0 or i &gt;= len(matrix) or j &lt; 0 or j &gt;= len(matrix[0]) or matrix[i][j] &lt;= pre: return 0 if (i, j) in self.dic: return self.dic[(i, j)] path = 1 + max(dfs(i + 1, j, matrix[i][j]), dfs(i - 1, j, matrix[i][j]), dfs(i, j - 1, matrix[i][j]), dfs(i, j + 1, matrix[i][j])) # 当前位置的最长递增路径的值是根据他4个方向的值得到的。 self.res = max(self.res, path) #维护最长路径的值 self.dic[(i, j)] = path #存储当前状态 return path for i in range(len(matrix)): for j in range(len(matrix[0])): dfs(i, j, float(&apos;-inf&apos;)) return self.res 时间复杂度O（mn * mn） 递归的时候一定要注意递归的条件，比如当前位置是不是在矩阵中，已经当前位置的值和之前位置的值的关系（因为我们要找的是递增序列）。 LeetCode 741 Cherry Pickup原题链接 12345678910111213141516171819202122232425262728293031323334353637383940In a N x N grid representing a field of cherries, each cell is one of three possible integers. 0 means the cell is empty, so you can pass through;1 means the cell contains a cherry, that you can pick up and pass through;-1 means the cell contains a thorn that blocks your way. Your task is to collect maximum number of cherries possible by following the rules below: Starting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1);After reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells;When passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0);If there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected. Example 1:Input: grid =[[0, 1, -1], [1, 0, -1], [1, 1, 1]]Output: 5Explanation: The player started at (0, 0) and went down, down, right right to reach (2, 2).4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].Then, the player went left, up, up, left to return home, picking up one more cherry.The total number of cherries picked up is 5, and this is the maximum possible. Note:grid is an N by N 2D array, with 1 &lt;= N &lt;= 50.Each grid[i][j] is an integer in the set &#123;-1, 0, 1&#125;.It is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1. 题目大意：二维矩阵中有3个状态，0代表可以通过，1代表该位置有樱桃可以通过，-1代表是个障碍无法通过。两个人同时从起点走向终点，问最多 总共得到多少樱桃。 这个题其实和上面的题的思想是一样的，都是找最大值路径的问题，只不过这个问题有两个人同时在走，所以需要我们同时维护两条路径，并且每一条 路径的前进方式可能不一样（下下，下右，右下，右右），不同的前进方式的收益是不一样的，我们需要找到最大的。两条路径和一条路径看上去复杂 一些，实际上没有任何区别，我们用一个状态同时存储两个点就是了。每一个状态都是跟之前的状态有关系，所以一样使用记忆化存储状态，然后碰见 处理过的状态直接调用就可以。直接看代码。 12345678910111213141516171819202122232425262728293031class Solution: def cherryPickup(self, grid: List[List[int]]) -&gt; int: dic = collections.defaultdict(int) #状态存储 if grid[-1][-1] == -1: #如果走不到终点，直接返回-1 return -1 def dp(i1, j1, i2, j2): if (i1, j1, i2, j2) in dic: #如果处理过这个状态，直接从字典中调取即可 return dic[(i1, j1, i2, j2)] if i1 == len(grid) or i2 == len(grid) or j1 == len(grid) or j2 == len(grid): return -1 #如果有一个点不在矩阵中，说明这个状态不合法 if i1 == len(grid) - 1 and i2 == len(grid) -1 and j1 == len(grid) - 1 and j2 == len(grid) - 1: return grid[-1][-1] # 递归的最深位置，我们需要获得这个位置的值 if grid[i1][j1] == -1 or grid[i2][j2] == -1: #碰到障碍，说明这条路不通，也返回-1 return -1 dd = dp(i1 + 1, j1, i2 + 1, j2) rr = dp(i1, j1 + 1, i2, j2 + 1) dr = dp(i1 + 1, j1, i2, j2 + 1) rd = dp(i1, j1 + 1, i2 + 1, j2) #上面的4个值，带表2条路径的前进模式 maxoutput = max(dd, rr, dr, rd) # 需要从不同的前进模式中找到最大收益 if maxoutput == -1: output = -1 else: #如果两条路径路过同一个点，我们只能摘1次樱桃！****** if i1 == i2 and j1 == j2: output = maxoutput + grid[i1][j1] else: output = maxoutput + grid[i1][j1] + grid[i2][j2] dic[(i1, j1, i2, j2)] = output #存储状态 return output return dp(0, 0, 0, 0) if dp(0, 0, 0, 0) &gt; 0 else 0]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 317,296 Shortest Distance from All Buildings]]></title>
    <url>%2F2019%2F07%2F02%2F317%2F</url>
    <content type="text"><![CDATA[LeetCode 296 Best Meeting Point原题链接 123456789101112131415161718A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.Example:Input: 1 - 0 - 0 - 0 - 1| | | | |0 - 0 - 0 - 0 - 0| | | | |0 - 0 - 1 - 0 - 0Output: 6 Explanation: Given three people living at (0,0), (0,4), and (2,2): The point (0,2) is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6. 题目大意：二维矩阵中只存在0和1,0代表是一个空着的位置，1代表一个人，要求在这个矩阵中找到一个位置，使得所有人都走到这个位置的曼哈顿距 离的和最短。 这道题虽然标记成hard题目，其实是一道比较容易的题，至少完全不够hard的难度。他要求的是曼哈顿距离，曼哈顿距离的实质其实就是两点之间的 横坐标的差的绝对值加上纵坐标差的绝对值。那么换个一个方向来思考这个问题，其实就是让我们寻找所有人中间的一个点，所有人到这个点的距离之 和就是最小距离。可能这么说比较难懂，那么我来通过几个比较简单的例子来解释这个问题。 1234567891011121314我们把这个问题简化成1维的数组来看：example1:[1, 6]一个人在位置1，另一个人在位置6，那么总距离为5，没什么好说的example2:[1,2,6]三个人在位置1，2，6，那么所有人都去位置2距离是最短的。为什么这么说呢，因为1和6在这中间任何一个点相遇的总距离都是一样的（6-1），但是2这个点的人如果不用动，就是最佳答案。 答案应该等于（6 - 1） + （2 - 2）example3:[1,2,3,6]在这个例子中，其实无论在位置2相遇或者位置3相遇，都是一样的，所有人都应该往最中心的点靠，用双指针来表示，每一次都应是总距离加上，右边指针的值减去左边指针的值，然后两个指针往中间移一个单位。 那么在二维数组中也是一样的，我们分别将横坐标和纵坐标分开来算就可以了，充分利用曼哈顿距离的性质。代码非常简单，就不多解释了。 12345678910111213141516171819202122class Solution: def minTotalDistance(self, grid: List[List[int]]) -&gt; int: rows = [] cols = [] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: rows.append(i) cols.append(j) cols = sorted(cols) res = 0 l, r = 0, len(rows) - 1 while l &lt; r: res += rows[r] - rows[l] r -= 1 l += 1 l, r = 0, len(cols) - 1 while l &lt; r: res += cols[r] - cols[l] r -= 1 l += 1 return res LeetCode 317 Shortest Distance from All Buildings原题链接 123456789101112131415161718192021222324You want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2, where:Each 0 marks an empty land which you can pass by freely.Each 1 marks a building which you cannot pass through.Each 2 marks an obstacle which you cannot pass through.Example:Input: [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]1 - 0 - 2 - 0 - 1| | | | |0 - 0 - 0 - 0 - 0| | | | |0 - 0 - 1 - 0 - 0Output: 7 Explanation: Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2), the point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.Note:There will be at least one building. If it is not possible to build such house according to the above rules, return -1. 题目其实和上面一题是差不多的，唯一不同的地方就是，二维数组里多了一个数字2,2代表着障碍，意思着不能从这里走。这下就变得比较有意思了， 障碍的出现意味着我们不能找中点来解决这个问题，因为有障碍的存在不能保证每个人到中点的距离都是无障碍的距离。而且障碍还有可能使一些人不 能走到一起，所有情况都要考虑到一起。 那么这时候我们首先需要扫描整个二维数组，知道一共有多少个人。这时候我们对每一个人的位置进行BFS遍历，然后更新每一个新到的位置距离这个 人的距离，同时我们还需要维护一个count(用三维数组来维护这个距离和总数），如果这个count在bfs结束后不等于总人数，那么直接返回-1。针对每一个位置进行BFS后，我们就可以找 到答案。代码还是比较好理解。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def shortestDistance(self, grid: List[List[int]]) -&gt; int: def bfs(i, j, seen): total = 0 queue = collections.deque([(i, j, 0)]) directions = [[1, 0], [-1, 0], [0, 1], [0, -1]] while queue: i, j, dis = queue.popleft() dp[i][j][0] += 1 dp[i][j][1] += dis for d in directions: newi, newj = i + d[0], j + d[1] if newi &lt; 0 or newi &gt;= len(grid) or newj &lt; 0 or newj &gt;= len(grid[0]) or grid[newi][newj] == 2 or (newi, newj) in seen: continue seen.add((newi, newj)) if grid[newi][newj] == 1: total += 1 continue queue.append((newi, newj, dis + 1)) return total dp = [[[0, 0] for _ in range(len(grid[0]))] for _ in range(len(grid))] total = 0 res = float(&apos;inf&apos;) for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: total += 1 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1 and bfs(i, j, set()) != total: return -1 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 0 and dp[i][j][0] == total: res = min(res, dp[i][j][1]) return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Weekly Contest 143]]></title>
    <url>%2F2019%2F06%2F30%2Fcontest143%2F</url>
    <content type="text"><![CDATA[LeetCode Weekly Contest 143LeetCode 1103 Distribute Candies to People题目链接1234567891011121314151617181920212223242526272829303132333435We distribute some number of candies, to a row of n = num_people people in the following way:We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person.Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person.This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end)until we run out of candies. The last person will receive all of our remaining candies (not necessarily one more than the previous gift).Return an array (of length num_people and sum candies) that represents the final distribution of candies. Example 1:Input: candies = 7, num_people = 4Output: [1,2,3,1]Explanation:On the first turn, ans[0] += 1, and the array is [1,0,0,0].On the second turn, ans[1] += 2, and the array is [1,2,0,0].On the third turn, ans[2] += 3, and the array is [1,2,3,0].On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].Example 2:Input: candies = 10, num_people = 3Output: [5,2,3]Explanation: On the first turn, ans[0] += 1, and the array is [1,0,0].On the second turn, ans[1] += 2, and the array is [1,2,0].On the third turn, ans[2] += 3, and the array is [1,2,3].On the fourth turn, ans[0] += 4, and the final array is [5,2,3]. 题目大意：给每个人分配糖果，从1个糖果开始，每一次分配后，加一个糖果，如果每个人都分配完一轮，还有剩余的，那么从头开始继续分配。 不用多解释，签到题。 123456789101112131415class Solution: def distributeCandies(self, candies: int, num_people: int) -&gt; List[int]: res = [0] * num_people start = 1 i = 0 while start &lt;= candies: res[i] += start candies -= start start += 1 i += 1 if i == len(res): i = 0 if candies: res[i] += candies return res LeetCode 1104 Path In Zigzag Labelled Binary Tree题目链接 123456789101112131415161718In an infinite binary tree where every node has two children, the nodes are labelled in row order.In the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.Given the label of a node in this tree, return the labels in the path from the root of the tree to the node with that label. Example 1:Input: label = 14Output: [1,3,4,14]Example 2:Input: label = 26Output: [1,2,6,10,26] 题目大意：从一个二叉树中找到一个路径，路径的终点是label。需要注意的是这个二叉树按照层序遍历，一行是正序，下一行是逆序的，直到结束。 这道题做的时候出现了重大的失误，感觉没有什么头绪，用了个Brute Force的方法构建一个二叉树，然后用DFS来找这个路径。真的是非常愚蠢了。 结果是超时的，耽误了很多时间。其实这道理有个规律,找到这个规律其实非常简单，当时脑子也是秀逗了。比如在第i层，那么这一层的所有数字都 应该在（2 ** i）到（2 ** （i + 1))这个区间里，我们从下到上来搜索，那么上一层的数字应该是下一层的数字除以2，并且取证，但是由于每一 层之间的顺序是不同的，所以我们只需要找到这个点的对称点即可，重复这些步骤，直到顶层，返回的时候，逆序结果输出就是答案了。 123456789101112131415161718class Solution: def pathInZigZagTree(self, label: int) -&gt; List[int]: level = -1 total = 0 while total &lt; label: level += 1 total += 2 ** level res = [label] level -= 1 cur = label // 2 while level &gt; -1: start, end = 2 ** level, (2 ** (level + 1)) - 1 cur = start + end - cur res.append(cur) cur = cur // 2 level -= 1 return res[::-1] LeetCode 1106 Parsing A Boolean Expression题目链接 123456789101112131415161718192021222324252627282930313233343536Return the result of evaluating a given boolean expression, represented as a string.An expression can either be:&quot;t&quot;, evaluating to True;&quot;f&quot;, evaluating to False;&quot;!(expr)&quot;, evaluating to the logical NOT of the inner expression expr;&quot;&amp;(expr1,expr2,...)&quot;, evaluating to the logical AND of 2 or more inner expressions expr1, expr2, ...;&quot;|(expr1,expr2,...)&quot;, evaluating to the logical OR of 2 or more inner expressions expr1, expr2, ... Example 1:Input: expression = &quot;!(f)&quot;Output: trueExample 2:Input: expression = &quot;|(f,t)&quot;Output: trueExample 3:Input: expression = &quot;&amp;(t,f)&quot;Output: falseExample 4:Input: expression = &quot;|(&amp;(t,f,t),!(t))&quot;Output: false Constraints:1 &lt;= expression.length &lt;= 20000expression[i] consists of characters in &#123;&apos;(&apos;, &apos;)&apos;, &apos;&amp;&apos;, &apos;|&apos;, &apos;!&apos;, &apos;t&apos;, &apos;f&apos;, &apos;,&apos;&#125;.expression is a valid expression representing a boolean, as given in the description. 这个题的意思就是就是返回整个字符串最后的结果，其中包含非，或，与，括号的操作。 这个题作为本子周赛标记为最难的题目，其实也不是很难，主要是要找到正确的方法。其实这个题如果没有括号是不是看上去就简单多了，我们直接 实现题目中这几个基本操作就可以了，但是加上了括号，这里面就存在一定的顺序。我的理解和别人不太一样，我是把这个题目看成计算器类型的题目， 因为在计算器类型的题目中，我们用栈来维护一些括号的操作，和这道题里面的情况是一样的，只不过运算符号，变成了逻辑运算符号。 首先我们需要维护当前的操作符号和字符，通过扫描数组把相对应的字符维护起来，当碰到左括号的时候，需要把左括号之前的字符串和操作符号入栈， 然后把操作符和字符串清零，来维护括号里面的元素。关键点在于碰到右括号的时候，我们需要把之前存入栈的操作符号和字符串pop出来，先pop出来 的是操作符，后pop出来的是字符串，用这个pop出来的操作符来操作当前的字符串，然后把结果添加到之前的字符串中，那么这时候相当于我们把这个 括号给去掉了，所以之前的整个字符串变成了当前字符串，继续重复上述操作。实现AND操作就是当数组中有False的时候出False，其他情况出True。 OR操作是有True出True，其他情况出False。（如果记不清楚的可以回去稍微复习下数字电子电路 - -）。 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def parseBoolExpr(self, expression: str) -&gt; bool: stack = [] string = &quot;&quot; op = &quot;&quot; for char in expression: if char in [&apos;!&apos;, &apos;&amp;&apos;, &apos;|&apos;]: op = char elif char in [&apos;t&apos;, &apos;f&apos;]: string += char elif char == &apos;(&apos;: stack.append(string) stack.append(op) string = &quot;&quot; op = &quot;&quot; elif char == &apos;)&apos;: ops = stack.pop() prestring = stack.pop() if ops == &apos;!&apos;: if string == &apos;t&apos;: prestring += &apos;f&apos; elif string == &apos;f&apos;: prestring += &apos;t&apos; elif ops == &apos;&amp;&apos;: if &apos;f&apos; in string: prestring += &apos;f&apos; else: prestring +=&apos;t&apos; elif ops == &apos;|&apos;: if &apos;t&apos; in string: prestring += &apos;t&apos; else: prestring += &apos;f&apos; string = prestring op = &quot;&quot; else: continue return True if string == &apos;t&apos; else False 计算器类似题目LeetCode 227 Basic Calculator IILeetCode 772 Basic Calculator IIILeetCode 224 Basic Calculator LeetCode 1105 Filling Bookcase Shelves题目链接 1234567891011121314151617181920212223242526272829We have a sequence of books: the i-th book has thickness books[i][0] and height books[i][1].We want to place these books in order onto bookcase shelves that have total width shelf_width.We choose some of the books to place on this shelf (such that the sum of their thickness is &lt;= shelf_width), then build another level of shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.Note again that at each step of the above process, the order of the books we place is the same order as the given sequence of books. For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.Return the minimum possible height that the total bookshelf can be after placing shelves in this manner.Example 1:Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4Output: 6Explanation:The sum of the heights of the 3 shelves are 1 + 3 + 2 = 6.Notice that book number 2 does not have to be on the first shelf. Constraints:1 &lt;= books.length &lt;= 10001 &lt;= books[i][0] &lt;= shelf_width &lt;= 10001 &lt;= books[i][1] &lt;= 1000 题目大意：有一个固定大小的抽屉，问怎么摆放才能使整个高度的值最小。 这道题在周赛的时候没有做出来，第二题耽误了太多的时间实在不应该，但是后来仔细做了一下这道题，感觉确实也没什么思路，其实判断出这个题目 是DP的题目并不难，因为如果把所有的书在不同的位置摆放出来，再计算高度，这个时间复杂度会非常非常的高，但是该怎么处理这个DP问题思考了很 久，DP问题一直是我的薄弱环节，经常摸不着头脑，不知道该怎么下手，确实需要一个针对DP的强化训练了。 简单的说一下思路，维护一个dp数组，dp中的每个位置代表到这个位置时最大的高度，通过扫描books，我们需要判断到底是把这本书继续排放在这一 行，还是说把这本书，连带前面几本书，在宽度限制的范围内一起放到下一行，我们需要得到这一个过程中的找到最小值，其实这就是dp中的转移方程。 1234567891011121314151617class Solution: def minHeightShelves(self, books: List[List[int]], shelf_width: int) -&gt; int: dp = [0] for i, b in enumerate(books): j = i w = shelf_width while j &gt;= 0 and w - books[j][0] &gt;= 0: #这个过程就是找出可以移动多少本书到下一行中。 w -= books[j][0] j -= 1 temp = float(&apos;inf&apos;) for k in range(j + 1, i + 1): #这个双循环就是找出这个过程中的最小值，到底连带几本书到下一行的情况是最佳的。 h = 0 for x in range(k, i + 1): h = max(h, books[x][1]) temp = min(temp, dp[k] + h) dp.append(temp) return dp[-1] 这周周赛总结就到这里，感觉在DP方面急需加强，不够DP也是一个比较难学的部分，里面涉及到模型非常多，继续加油！]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Biweekly Contest 3 总结]]></title>
    <url>%2F2019%2F06%2F29%2Fbiweekly3%2F</url>
    <content type="text"><![CDATA[LeetCode Biweekly Contest 3LeetCode 1099 Two Sum Less Than K题目链接 12345678910111213141516171819202122232425Given an array A of integers and integer K, return the maximum S such that there exists i &lt; j with A[i] + A[j] = S and S &lt; K. If no i, j exist satisfying this equation, return -1. Example 1:Input: A = [34,23,1,24,75,33,54,8], K = 60Output: 58Explanation: We can use 34 and 24 to sum 58 which is less than 60.Example 2:Input: A = [10,20,30], K = 15Output: -1Explanation: In this case it&apos;s not possible to get a pair sum less that 15. Note:1 &lt;= A.length &lt;= 1001 &lt;= A[i] &lt;= 10001 &lt;= K &lt;= 2000 题目大意：从数组中找两个数字，他们的和必须小于K，求最大的值。（类似于Amazon某一段时间的OA），比较容易算是一个签到题。 看了一下数据 规模，也没想太多，直接Brute Force就通过了。 12345678class Solution: def twoSumLessThanK(self, A: List[int], K: int) -&gt; int: res = -1 for i in range(len(A) - 1): for j in range(i + 1, len(A)): if A[i] + A[j] &lt; K: res = max(res, A[i] + A[j]) return res 比赛结束，重新思考了一下，其实先将数组排序，然后用双指针来操作，会更快一点。 123456789101112class Solution: def twoSumLessThanK(self, A: List[int], K: int) -&gt; int: A.sort() res = -1 l, r = 0, len(A) - 1 while l &lt; r: if A[l] + A[r] &gt;= K: r -= 1 else: res = max(res, A[l] + A[r]) l += 1 return res LeetCode 1100 Find K-Length Substrings With No Repeated Characters题目链接123456789101112131415161718192021222324Given a string S, return the number of substrings of length K with no repeated characters. Example 1:Input: S = &quot;havefunonleetcode&quot;, K = 5Output: 6Explanation: There are 6 substrings they are : &apos;havef&apos;,&apos;avefu&apos;,&apos;vefun&apos;,&apos;efuno&apos;,&apos;etcod&apos;,&apos;tcode&apos;.Example 2:Input: S = &quot;home&quot;, K = 5Output: 0Explanation: Notice K can be larger than the length of S. In this case is not possible to find any substring. Note:1 &lt;= S.length &lt;= 10^4All characters of S are lowercase English letters.1 &lt;= K &lt;= 10^4 题目大意：求一个字符串中有多少个长度为K的子字符串，要求没有重复的元素。 通过一个滑动窗口来扫描整个数组就可以得到答案，时间复杂度O（n) 12345678910111213141516171819class Solution: def numKLenSubstrNoRepeats(self, S: str, K: int) -&gt; int: if len(S) &lt; K: return 0 res = 0 dic = collections.Counter() l, r = 0, 0 while r &lt; len(S): dic[S[r]] += 1 if r - l + 1 &gt; K: dic[S[l]] -= 1 if dic[S[l]] == 0: del dic[S[l]] l += 1 if r - l + 1 == K: if len(dic) == K: res += 1 r += 1 return res LeetCode 1101 The Earliest Moment When Everyone Become Friends题目链接 12345678910111213141516171819202122232425262728293031323334In a social group, there are N people, with unique integer ids from 0 to N-1.We have a list of logs, where each logs[i] = [timestamp, id_A, id_B] contains a non-negative integer timestamp, and the ids of two different people.Each log represents the time in which two different people became friends. Friendship is symmetric: if A is friends with B, then B is friends with A.Let&apos;s say that person A is acquainted with person B if A is friends with B, or A is a friend of someone acquainted with B.Return the earliest time for which every person became acquainted with every other person. Return -1 if there is no such earliest time. Example 1:Input: logs = [[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],[20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]], N = 6Output: 20190301Explanation: The first event occurs at timestamp = 20190101 and after 0 and 1 become friends we have the following friendship groups [0,1], [2], [3], [4], [5].The second event occurs at timestamp = 20190104 and after 3 and 4 become friends we have the following friendship groups [0,1], [2], [3,4], [5].The third event occurs at timestamp = 20190107 and after 2 and 3 become friends we have the following friendship groups [0,1], [2,3,4], [5].The fourth event occurs at timestamp = 20190211 and after 1 and 5 become friends we have the following friendship groups [0,1,5], [2,3,4].The fifth event occurs at timestamp = 20190224 and as 2 and 4 are already friend anything happens.The sixth event occurs at timestamp = 20190301 and after 0 and 3 become friends we have that all become friends. Note:1 &lt;= N &lt;= 1001 &lt;= logs.length &lt;= 10^40 &lt;= logs[i][0] &lt;= 10^90 &lt;= logs[i][1], logs[i][2] &lt;= N - 1It&apos;s guaranteed that all timestamps in logs[i][0] are different.Logs are not necessarily ordered by some criteria.logs[i][1] != logs[i][2] 这个题目看上去很长，简单的来说就是一个朋友圈问题。一个数组里面有一些子数组，每个子数组第一个位置代表时间，第二个和第三个位置代表两个 不同的人。这两个人会在这个时间成为朋友，如果这两个人成为朋友，那么这两个人所处在的朋友圈里的所有人都将成为朋友，要求我们返回最小的时 间，使得所有人成为朋友。 这是一个比较典型的Union Find的问题，把每个人合并到一个圈子里，直到这个圈子包含了所有的人。Union Find的题目其实框架都是一样，在这 道题目中，当我们发现，两个人所处的朋友圈不一样时，我们需要合并这两个朋友圈，合并成功我们要从总人数中减去1，当count等于0的时候，说明 所有人都已经在一个朋友圈里了，这时候直接返回时间即可（需要对数组通过时间进行排序）。 123456789101112131415161718192021222324252627282930313233class Solution: def earliestAcq(self, logs: List[List[int]], N: int) -&gt; int: def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): px, py = find(x), find(y) if px == py: return else: if rank[px] == rank[py]: parent[py] = px rank[px] += rank[py] elif rank[px] &gt; rank[py]: parent[py] = px rank[px] += rank[py] elif rank[px] &lt; rank[py]: parent[px] = py rank[py] += rank[px] self.count -= 1 logs.sort() parent = [i for i in range(N)] rank = [1 for _ in range(N)] self.count = N - 1 res = 0 for log in logs: union(log[1], log[2]) if self.count == 0: return log[0] return -1 LeetCode 1102 Path With Maximum Minimum Value原题链接 1234567891011121314151617181920212223242526272829303132333435Given a matrix of integers A with R rows and C columns, find the maximum score of a path starting at [0,0] and ending at [R-1,C-1].The score of a path is the minimum value in that path. For example, the value of the path 8 → 4 → 5 → 9 is 4.A path moves some number of times from one visited cell to any neighbouring unvisited cell in one of the 4 cardinal directions (north, east, west, south). Example 1:Input: [[5,4,5],[1,2,6],[7,4,6]]Output: 4Explanation: The path with the maximum score is highlighted in yellow. Example 2:Input: [[2,2,1,2,2,2],[1,2,2,2,1,2]]Output: 2Example 3:Input: [[3,4,6,3,4],[0,2,1,1,7],[8,8,3,2,7],[3,2,4,9,8],[4,1,2,0,0],[4,6,5,4,3]]Output: 3 Note:1 &lt;= R, C &lt;= 1000 &lt;= A[i][j] &lt;= 10^9 这道题目不知道为啥通过率为啥这么低，可能好多人和我有一样的误解，大早上可能没睡醒。一开始我以为是找一条路径，从起点到终点，这条路径的 和是最大的，求路径中的最小值。（没仔细读题）看了案例感觉差不多，直接就开始写了，后来发现怎么都无法通过。重新审题，发现其实完全不是这 样。其实就是找一条路径，得到到这个路径中的最小值，使得这个值比其他路径中的最小值要大。 理解清楚后，可能很多人上来都会直接用深度优先搜索(DFS)来解决这个问题，这样做肯定是没问题的，但是在这道题目的数据规模和时间限制下是无 法AC的。粗略计算一下，每个点都有3个不同的方向，时间复杂度大约是O（(r * c) ** 3),时间复杂度非常高。仔细一想可以把这道题简化成找最大 值的问题，先上代码。 class Solution: def maximumMinimumPath(self, A: List[List[int]]) -&gt; int: heap = [(-A[0][0], 0, 0)] dp = [[0 for _ in range(len(A[0]))] for _ in range(len(A))] dp[0][0] = A[0][0] directions = [[1, 0], [-1, 0], [0, 1], [0, -1]] while heap: num, i, j = heapq.heappop(heap) val = -num for d in directions: newi, newj = i + d[0], j + d[1] if 0 &lt;= newi &lt; len(A) and 0 &lt;= newj &lt; len(A[0]): temp = min(val, A[newi][newj]) if temp &gt; dp[newi][newj]: dp[newi][newj] = temp heapq.heappush(heap,(-temp, newi, newj)) return dp[-1][-1] 首先需要建立一个堆数组，和一个dp矩阵，通过维护这个dp矩阵来找最终答案，也是为了优化时间复杂度。dp矩阵中每个元素代表的是不同路径到这个 点的时候，在路径中最小的最大值（好拗口。。）。找最大值这个过程其实就用堆排序来实现就可以，当然在python的自带的堆排序模块中，全部都是 最小堆（在之前的文章中提到过这个问题），要转换成最大堆，我们存入堆的元素需要取负即可。每一次操作如果这个位置的元素值不如dp数组中这个 位置的数值大，我们可以不在将其存入堆中，如果大于这个数字，我们需要将新的数字重新入堆，参与下一次循环。 总结这次的双周周赛感觉还是比较容易，但是自己在一些地方处理的不太好，导致有的地方速度很慢，也跟不熟练有关系，反应很慢。继续努力吧！Fight！]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 239 Sliding Window Maximum 滑动窗口最大值]]></title>
    <url>%2F2019%2F06%2F29%2Fwindow%2F</url>
    <content type="text"><![CDATA[LeetCode 239 Sliding Window Maximum 滑动窗口最大值原题链接 1234567891011121314151617181920Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the veryright. You can only see the k numbers in the window. Each time the sliding window moves right by one position.Return the max sliding window.Example:Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7Note: You may assume k is always valid, 1 ≤ k ≤ input array&apos;s size for non-empty array. 题目大意：给定一个固定size(k)的滑动窗口，当窗口滑动到不同位置时，存储当前窗口内的最大值。 这道题我第一眼看到的时候感觉这道题真的容易，完全不像一个hard的问题，直接上来就建立一个滑动窗口然后开始扫描整个数组，然后记录最大值， 当然了这个做法是没有任何问题的，但是这个问题在LeetCode里的测试案例的数据规模非常小，所以也能AC。 123456789#Brute forceclass Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: if not nums: return [] res = [] for i in range(len(nums) - k + 1): res.append(max(nums[i: i + k])) return res 上述的做法，时间复杂度是O（n * k),因为每次扫描，我们都需对当前窗口来计算最大值是多少，每一次调用max()方法，时间复杂度都是O（k)(窗 口的大小）。假设整个数组的长度非常大，窗口的尺寸也非常大，那么这个时间复杂度其实是O（n ** 2),效率就非常低了，所以我们需要对整个窗口 进行优化。 找最大值或者最小值，其实比较常规的方法就是堆排（Heap Sort），每次找最大值的时候时间复杂度为O(logn),避免每次都要重新扫描窗口。 1234567891011121314151617181920class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: res = [] if not nums: return res window = [] for i in range(k): heapq.heappush(window, -nums[i]) res.append(-window[0]) pop = collections.Counter() for i in range(k, len(nums)): out = nums[i - k] inn = nums[i] pop[out] += 1 heapq.heappush(window, -inn) while pop[-window[0]] &gt; 0: pop[-window[0]] -= 1 heapq.heappop(window) res.append(-window[0]) return res 还有一种更快捷的方法，用队列来解决这个问题，其实这个问题可以简化成维护一个队列，我们只需要知道当前的最大值是多少，还有当前最大值是不 是在这个窗口里，其他的事情其实都不需要考虑，这样一来时间复杂度可以简化到O（n）。 12345678910111213class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: window = collections.deque() res = [] for i, num in enumerate(nums): while window and num &gt; nums[window[-1]]: window.pop() window.append(i) if i &gt;= k - 1: res.append(nums[window[0]]) if i - k + 1 == window[0]: window.popleft() return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>滑动窗口（Sliding Window）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 72 Edit Distance 编辑距离]]></title>
    <url>%2F2019%2F06%2F27%2Fdistance%2F</url>
    <content type="text"><![CDATA[LeetCode 72 Edit Distance原题链接 123456789101112131415161718192021222324252627Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.You have the following 3 operations permitted on a word:Insert a characterDelete a characterReplace a characterExample 1:Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)rorse -&gt; rose (remove &apos;r&apos;)rose -&gt; ros (remove &apos;e&apos;)Example 2:Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &apos;t&apos;)inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;)enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;)exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;)exection -&gt; execution (insert &apos;u&apos;) 题目大意，将word1变成word2，最少需要多少步骤。一般碰到这种问题，尽量不要想着用Brute Force的方法去解决，因为如果想通过找出所有可能 的单词，来计算最少步骤数目，时间复杂度是非常高的，因为一个位置可以替换26个字母或者添加或删除一个字母，时间复杂度是指数增长的。所以这 种时候需要通过动态规划来解决这个问题。动态规划的本质是通过一个小的问题来解决较大规模的问题。但是如何找到转移方程，是DP类问题的关键， 也是解决DP问题最难的地方。有的时候知道这个问题需要用DP来解决，但是却无从下手，这种情况非常正常，其实个人认为在LeetCode中最难的一部 分问题就是DP了，只能通过更多的练习来强化。 这个问题是一道Hard的题目，但是代码非常短，像一个easy的题目，但是这其中需要思考的问题很多，以及如何去理解这个题目中DP的意义。先上 代码！ 1234567891011121314class Solution: def minDistance(self, word1: str, word2: str) -&gt; int: dp = [[0 for _ in range(len(word1) + 1)] for _ in range(len(word2) + 1)] for i in range(1, len(dp)): dp[i][0] = i for i in range(1, len(dp[0])): dp[0][i] = i for i in range(1, len(dp)): for j in range(1, len(dp[0])): if word1[j - 1] == word2[i - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1 return dp[-1][-1] 首先构建一个DP的二维矩阵，如果练习的够多可以总结出，要解决对比两个字符串的问题，基本都是可以基于一个二维的DP数组来解决。首先来解释一 下dp[i][j]的含义。dp[i][j]代表的是word1[:j]变成word2[:i]需要多少步，而且dp[i][j]只和dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]有关，也就是说，和最近的三个子问题有关。现在的问题是这三个子问题都代表什么，如何实现通过dp来实现，insert, remove, replace的操作。我简单的通过几个简单的例子来解释。 123456789101112131415remove:word1 = &quot;ab&quot;, word2 = &quot;a&quot;这个可以比较容易的看出，如果想把word1变成word2最快的方法就是将word1末尾的&quot;b&quot;删除掉。dp[i][j] = dp[i][j - 1] + 1dp[i][j - 1]是word1 = &quot;a&quot; word2 = &quot;a&quot;的时候，因为要移除&quot;b&quot;,所以要多一次操作。insert:word1 = &quot;a&quot;, word2 = &quot;ab&quot;这个例子中，需要在word1中添加一个&quot;b&quot;才能和word2一样。dp[i][j] = dp[i - 1][j] + 1replace:word1 = &quot;ab&quot;, word2 = &quot;ac&quot;将word1中的&quot;b&quot;替换成&quot;c&quot;，也就是说需要从两个字符串都是&quot;a&quot;的状态来替换(dp[i - 1][j - 1])dp[i][j] = dp[i - 1][j - 1] + 1 这样如何完成这三种操作的方法已经介绍完了，这道题还有一个要点，就是要初始化dp，因为不初始化dp的话，所有位置的起始状态都是0，这是不对 的，因为我们的最初状态是从两个空的字符串开始的，然后逐渐往后延伸，所以每一个字符串要想变成空字符串的话，也就是当前位置的数字等于当前 字符串的长度。 123456Initialize:dp = [[0 for _ in range(len(word1) + 1)] for _ in range(len(word2) + 1)] for i in range(1, len(dp)): dp[i][0] = i for i in range(1, len(dp[0])): dp[0][i] = i 最后返回dp[-1][-1]就是最小的步数。]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 924 Minimize Malware Spread 最大限度减少恶意软件传播]]></title>
    <url>%2F2019%2F06%2F26%2FSpread%2F</url>
    <content type="text"><![CDATA[LeetCode 924 Minimize Malware Spread原题链接 这道题是LeetCode中属于hard难度的题目，也是一道高频题，个人认为这道题是一道非常典型的题目。题目很长，大概意思就是，有一些节点，其中 一些节点被病毒感染了，某一些节点之间是相互连接的（形成一个图），如果这个图中有一个节点是被病毒感染的，那么整个图都会被感染。要求我们 找到其中一个被感染的节点，并删除他，使所有节点受感染的数目最少。 例子 1234567891011121314151617181920212223Example 1:Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]Output: 00---120和1构成一个图， 2不和任何节点连接，由于0和1同时都被病毒感染，所以按照题目要求我们需要返回一个较小数字的节点。Example 2:Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]Output: 0例子2和例子1其实是类似的。Example 3:Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]Output: 1 0 -- 1 \ / 2这三个节点彼此相互连接， 所以仍然是返回哪个比较小的被感染节点。 其实通过上述三个例子，不是很容易弄明白这个问题。如果在一个图中，有至少有两个以上的节点是被病毒感染的，那么其实无论删除哪个，都不能避 免整个图被感染。所以在扫描整个图时，如果存在这么一个图，图中只有一个节点是被感染的，那么我们如果删除这个节点就可以使这一部分的图，全 变成正常情况。依照这个原则去搜索，即可找出答案。 首先我们需要构造这个图，构图这部分我喜欢写在Union Find的类里面，然后在主函数中进行搜索就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class UnionFind: def __init__(self, graph): self.parent = [i for i in range(len(graph))] self.rank = [1 for _ in range(len(graph))] for i in range(len(graph)): for j in range(i + 1, len(graph[0])): if graph[i][j] == 1 and i != j: self.union(i, j) def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): px, py = self.find(x), self.find(y) if px == py: return if self.rank[px] == self.rank[py]: self.parent[py] = px self.rank[px] += self.rank[py] else: if self.rank[px] &gt; self.rank[py]: self.parent[py] = px self.rank[px] += self.rank[py] else: self.parent[px] = py self.rank[py] += self.rank[px]#上面这个class是UnionFind和图的构造过程，UnionFind在寻找每个节点的父亲节点的平均用时是O（1），所以这个结构对于构造一个图来说是非常高效的。class Solution: def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -&gt; int: uf = UnionFind(graph) dic = collections.defaultdict(list) for i, e in enumerate(uf.parent): dic[e].append(i) #用字典来保存每一个图 res = min(initial) #如果找不到更优的结果，我们需要返回最小值 initial = set(initial) #将病毒节点数组转换成集合，方便搜索（集合中搜索元素的时间复杂度是O（1） mincount = 0 for node in dic: seen = set() for n in dic[node]: if n in initial: seen.add(n) #找出图中所有被感染的节点 if len(seen) == 1: #判断该删除哪个节点 if len(dic[node]) &gt; mincount or (len(dic[node]) == mincount and list(seen)[0] &lt; res): res = list(seen)[0] mincount = len(dic[node]) return res 如果想避免构图这个过程，这道题可以直接用深度优先搜索来求解，深度优先搜索(DFS)的代码更加简洁，但是Union Find的代码看上去更加直观。 1234567891011121314151617181920212223#DFSclass Solution: def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -&gt; int: def dfs(node,vis): for v in range(len(graph[node])): if graph[node][v] == 1 and v not in vis: vis.add(v) dfs(v,vis) seen = set() res = min(initial) initial = set(initial) mincount = 0 for node in range(len(graph)): if node not in seen: vis = set([node]) dfs(node,vis) infect = vis &amp; initial if len(infect) == 1: if len(vis) &gt; mincount or (len(vis) == mincount and list(infect)[0] &lt; res): res = list(infect)[0] mincount = len(vis) seen |= vis return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>Union Find</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 215 Kth Largest Element in an Array 排序算法总结]]></title>
    <url>%2F2019%2F06%2F25%2F215%2F</url>
    <content type="text"><![CDATA[LeetCode 215 Kth Largest Element in an Array原题链接 题目大意：从一个未排序的数组中找到第K大的元素。 其实想单纯的解决这个问题真的是非常容易，在Python中一行代码就可以解决。 One - line12def findKthLargest1(self, nums, k): return sorted(nums, reverse = True)[k - 1] 在Python中，sort()方法的时间复杂度是O(nlogn),其实看到第K个元素问题，第一时间想到方法应该是堆排序（Heap Sort), 每一次pop出一个 元素，循环K次即可找到答案。 Heap Sort在这里堆排序可以节省很多时间，但是这里存在着到底是用最大堆(Max heap)还是最小堆(Min Heap)的问题。在Python中，heap模块自动生成的是 最小堆，如果想生成一个最大堆，我们需要将数组中所有的数字取负数，然后重新堆化(Heapify)。那么两者的时间复杂度为 O(n + xlogn), 为什么我这里使用了x， 其实到底是最小堆快还是最大堆快，取决于k到底是靠近数组的开始，还是靠近数组的结尾。如果K在数组的 中间位置，那么两者的时间复杂度其实几乎是一样的。如果K靠近起始位置，那么肯定Min Heap会快，反之亦然。 Min Heap1234567class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: heapq.heapify(nums) res = 0 for _ in range(len(nums) - k + 1): res = heapq.heappop(nums) return res Max Heap12345678class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: heap = [-num for num in nums] heapq.heapify(heap) res = 0 for _ in range(k): res = -heapq.heappop(heap) return res 排序算法(Python 版本)其实这道题考察的是到底该使用那种排序算法，我简单的对几种常用的排序算法进行一下总结。 冒泡排序(Bubble Sort)冒牌排序的本质其实是针对相邻元素，如果第一个元素比第二个元素大，那么交换两者的位置，重复上述的步骤，直到没有可以交换的元素。 平均时间复杂度：O(n ** 2) 最坏时间复杂度：O(n ** 2) 最好时间复杂度：O(n) 空间复杂度： O(1) in-place 123456def BubbleSort(nums): for i in range(1, len(nums)): for j in range(len(nums) - i): if nums[j] &gt; nums[j + 1]: nums[j], nums[j + 1] = nums[j + 1], nums[j] return nums 选择排序(Selection Sort)在未排序数组中找到最大（小）的元素，放在每一轮起始的位置，每一轮结束后，接下来在剩余的数组中继续操作。 平均时间复杂度：O（n ** 2) 最好时间复杂度：O（n ** 2) 最坏时间复杂度：O（n ** 2) 空间复杂度： O（1） in - place 123456789def SelectionSort(nums): for i in range(len(nums) - 1): index = i for j in range(i + 1, len(nums)): if nums[j] &lt; nums[index]: index = j if index != i: nums[index], nums[i] = nums[i], nums[index] return nums 插入排序（Insertion Sort）扫描整个数组，然后针对这个位置上的数字进行操作，如果这个数字比前面的数字小，就一直往前移动，直到整个数组没有可以操作的元素。 平均时间复杂度：O（n ** 2) 最好时间复杂度：O（n) 最坏时间复杂度：O（n ** 2） 空间复杂度： O（1） in - place 123456789def InsertionSort(nums): for i in range(len(nums)): pre = i - 1 cur = nums[i] while pre &gt;= 0 and arr[pre] &gt; cur: arr[pre + 1] = arr[pre] pre -= 1 arr[pre + 1] = cur return nums 希尔排序(Shell Sort)希尔排序法(缩小增量法) 属于插入类排序，是将整个无序列分割成若干小的子序列分别进行插入排序的方法。 平均时间复杂度：O（nlogn) 最好时间复杂度：O（n） 最坏时间复杂度：O（n ** 2） 空间复杂度：O（1）in - place 1234567891011121314def ShellSort(nums): gap = 1 while gap &lt; len(nums) // 2: gap = gap * 3 + 1 while gap &gt; 0: for i in range(gap, len(nums)): temp = nums[i] j = i - gap while j &gt;= 0 and nums[j] &gt; temp: nums[j + gap] = nums[j] j -= gap nums[j + gap] = temp gap = gap // 3 return nums 归并排序(Merge Sort)将一个完整的数组拆分成一些子序列，然后分别针对子序列进行排序，最后在合并到一起，Divide and Conquer的思想。 时间复杂度：O(nlogn) 空间复杂度：O（n） 12345678910111213141516171819202122def MergeSort(nums): if len(nums) &lt; 2: return nums mid = len(nums) // 2 return merge(MergeSort(nums[:mid]), MergeSort(nums[mid:]))def merge(l, r): nums = [] a, b = 0, 0 while a &lt; len(l) and b &lt; len(r): if l[a] &lt; r[b]: nums.append(l[a]) a += 1 else: nums.append(r[b]) b += 1 if a &lt; len(l): nums += l[a:] if b &lt; len(r): nums += r[b:] return nums 快速排序(Quick Sort)找到一个轴，比这个轴大的数字放在一个数组，比轴小的数字放在另一个数组，然后用递归加分而治之对子数组进行相同的操作，最后合并所有子数组。 平均时间复杂度：O（nlogn） 最好时间复杂度：O（nlogn） 最坏时间复杂度：O（n ** 2) 空间复杂度： O（nlogn） 12345678910111213def QuickSort(nums): if len(nums) &lt; 2: return nums else: mid = nums[len(nums) // 2] left = [] right = [] for num in nums: if num &gt; mid: right.append(num) else: left.append(num) return QuickSort(left) + [mid] + QuickSort(right)]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 79, 212 Word Search]]></title>
    <url>%2F2019%2F06%2F24%2FWordSearch%2F</url>
    <content type="text"><![CDATA[LeetCode 79 Word Search原题链接 题目大意：给定一个二维的网格和一个单词，判断单词是否在网格中。 单词必须按照字母顺序，通过相邻的单元格的字母组成，其中相邻指的是4个方向（上，下，左，右），同一个单元格中的单词不能重复使用。 例子12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false. 这道题目，只需要查找一个单词，所以直接暴力求解(bracktrack)就可以。遍历二维网格，找到一个符合要求的开头（单词的首字母），然后以这个 点为起点，进行回溯。 123456789101112131415161718192021222324class Solution: def exist(self, board: List[List[str]], word: str) -&gt; bool: for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == word[0]: if self.dfs(board, i, j, 0, word): return True return False def dfs(self, board, i, j, index, word): if index == len(word): return True if i &lt; 0 or i &gt;= len(board) or j &lt; 0 or j &gt;= len(board[0]) or board[i][j] != word[index]: return False board[i][j] = &apos;#&apos; if self.dfs(board, i - 1, j, index + 1, word): return True if self.dfs(board, i + 1, j, index + 1, word): return True if self.dfs(board, i, j - 1, index + 1, word): return True if self.dfs(board, i , j + 1, index + 1, word): return True board[i][j] = word[index] #LeetCode 212 Word Search II 原题链接12345678910Input: board = [ [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;], [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;], [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;], [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]]words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]Output: [&quot;eat&quot;,&quot;oath&quot;] 这道题其实是Word Search 的升级版，区别在于，前者只要求查找一个单词，后者需要从一个数组中查找每一个单词。我们不可以再像第一题这样直 接进行暴力求解。需要先对整个数组进行预处理。需要使用一个特殊的数据结构叫做字典树（Trie）。在Python中，如果想从一个字典中搜索一个元 素，时间复杂度为O(1),这样可以大大减少我们在搜索中所用的时间。 1&#123;&apos;o&apos;: &#123;&apos;a&apos;: &#123;&apos;t&apos;: &#123;&apos;h&apos;: &#123;&apos;end&apos;: &apos;#&apos;&#125;&#125;&#125;&#125;, &apos;p&apos;: &#123;&apos;e&apos;: &#123;&apos;a&apos;: &#123;&apos;end&apos;: &apos;#&apos;&#125;&#125;&#125;, &apos;e&apos;: &#123;&apos;a&apos;: &#123;&apos;t&apos;: &#123;&apos;end&apos;: &apos;#&apos;&#125;&#125;&#125;, &apos;r&apos;: &#123;&apos;a&apos;: &#123;&apos;i&apos;: &#123;&apos;n&apos;: &#123;&apos;end&apos;: &apos;#&apos;&#125;&#125;&#125;&#125;&#125; 对于整个数组预处理过后，字典树如上图，一定要注意用一个标志（&quot;end&quot;)来表明一个完整单词的结束。否则我们无法确定这是一个完整的单词，还是 一个单词的一部分。 backtrack的过程和上一题的过程累似，只不过需要不断更新root（当前字母作为根节点），然后进行搜索，直到结束。 12345678910111213141516171819202122232425262728class Solution: def findWords(self, board: List[List[str]], words: List[str]) -&gt; List[str]: dic = &#123;&#125; self.res = set() for word in words: node = dic for char in word: if char not in node: node[char] = &#123;&#125; node = node[char] node[&apos;end&apos;] = &apos;#&apos; for i in range(len(board)): for j in range(len(board[0])): self.dfs(dic, board, i, j, &quot;&quot;) return list(self.res) def dfs(self, node, board, i, j, path): if &apos;end&apos; in node: self.res.add(path) if i &lt; 0 or i &gt;= len(board) or j &lt; 0 or j &gt;= len(board[0]) or board[i][j] not in node: return temp = board[i][j] board[i][j] = &apos;#&apos; self.dfs(node[temp], board, i - 1, j, path + temp) self.dfs(node[temp], board, i + 1, j, path + temp) self.dfs(node[temp], board, i, j - 1, path + temp) self.dfs(node[temp], board, i, j + 1, path + temp) board[i][j] = temp]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>BackTrack</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于刷题]]></title>
    <url>%2F2019%2F06%2F23%2FLeetCode%2F</url>
    <content type="text"><![CDATA[LeetCode关于刷题 在现在的大环境下，刷题似乎成为了大部分人的必经之路，越来越多的公司在面试中通过相关题目，来考察求职者。就算已经找到工作的人，也 有很多人每天保持着练习，为了防止自己手生。其实无论到底出于什么目的，刷题真的很重要，当然，刷题不一定能确保你找到一份好的工作，但是 不刷题感觉基本没有设么机会。作为一个转专业的选手（从硬件到软件），这段经历真的是挺痛苦的，刚开始刷题的时候什么都不会，到坚持了6个 月， 刷了900道题，将近4500个submission。这段路真的非常艰辛，但是一定要咬着牙走下去。 看着上面的图，稍微有一点点成就感，但是更多的感觉到一点点忧伤，因为真的感觉好辛苦好累。做这个博客，一个想记录一下自己刷题的生 活，顺便把一些重点的题目的思路重新理一下，并分享给需要的人。我用的是Python（别问， 人生苦短，我用？？？？），以后有机会会试着用 Java写一写。]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
