<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 488 Zuma Game]]></title>
    <url>%2F2019%2F07%2F30%2F488%2F</url>
    <content type="text"><![CDATA[LeetCode 488 Zuma Game原题链接 12345678910111213141516171819202122232425262728293031Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.Examples:Input: &quot;WRRBBW&quot;, &quot;RB&quot;Output: -1Explanation: WRRBBW -&gt; WRR[R]BBW -&gt; WBBW -&gt; WBB[B]W -&gt; WWInput: &quot;WWRRBBWW&quot;, &quot;WRBRW&quot;Output: 2Explanation: WWRRBBWW -&gt; WWRR[R]BBWW -&gt; WWBBWW -&gt; WWBB[B]WW -&gt; WWWW -&gt; emptyInput:&quot;G&quot;, &quot;GGGGG&quot;Output: 2Explanation: G -&gt; G[G] -&gt; GG[G] -&gt; empty Input: &quot;RBYYBBRRB&quot;, &quot;YRBGB&quot;Output: 3Explanation: RBYYBBRRB -&gt; RBYY[Y]BBRRB -&gt; RBBBRRB -&gt; RRRB -&gt; B -&gt; B[B] -&gt; BB[B] -&gt; empty Note:You may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color.The number of balls on the table won&apos;t exceed 20, and the string represents these balls is called &quot;board&quot; in the input.The number of balls in your hand won&apos;t exceed 5, and the string represents these balls is called &quot;hand&quot; in the input.Both input strings will be non-empty and only contain characters &apos;R&apos;,&apos;Y&apos;,&apos;B&apos;,&apos;G&apos;,&apos;W&apos;. 题目大意：祖玛游戏，求最少的次数将所有字符消掉。 这个题目其实不是很难，考的是搜索的基本功，通过一个例子来简单的分析一下这个题。 1234567Input: &quot;WWRRBBWW&quot;, &quot;WRBRW&quot;Output: 2Explanation: WWRRBBWW -&gt; WWRR[R]BBWW -&gt; WWBBWW -&gt; WWBB[B]WW -&gt; WWWW -&gt; empty首先需要扫描数组，碰到连续的字符串，如果在我们手中存在相同的字符，可以打出去或者不打出去，来消掉字符串。在上面的例子中，消掉R和B，最后4个W直接互相消掉，其实还有一种策略，先消除掉前两个W，在一次消除后面的字符串。但是这不是最优解，不过通过这个案例可以看出这是一个回溯的思想，遇到连续的字符，我们可以选择消或者不消来找最大值。 用字典来存储手中的字符个数，然后递归搜索即可找到最优解。 1234567891011121314151617181920212223class Solution: def findMinStep(self, board: str, hand: str) -&gt; int: count = collections.Counter(hand) def dfs(s, count): if not s: return 0 res, i = float(&apos;inf&apos;), 0 while i &lt; len(s): j = i + 1 while j &lt; len(s) and s[j] == s[i]: j += 1 dif = 3 - (j - i) if count[s[i]] &gt;= dif: if dif &lt; 0: dif = 0 count[s[i]] -= dif temp = dfs(s[:i] + s[j:], count) if temp &gt;= 0: res = min(res, temp + dif) count[s[i]] += dif i = j return res if res != float(&apos;inf&apos;) else -1 return dfs(board, count)]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>Backtrack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Contest 147]]></title>
    <url>%2F2019%2F07%2F28%2Fcontest147%2F</url>
    <content type="text"><![CDATA[LeetCode 1137 N-th Tribonacci Number原题链接 12345678910111213141516171819202122232425The Tribonacci sequence Tn is defined as follows: T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &gt;= 0.Given n, return the value of Tn. Example 1:Input: n = 4Output: 4Explanation:T_3 = 0 + 1 + 1 = 2T_4 = 1 + 1 + 2 = 4Example 2:Input: n = 25Output: 1389537 Constraints:0 &lt;= n &lt;= 37The answer is guaranteed to fit within a 32-bit integer, ie. answer &lt;= 2^31 - 1. 这道题和之前leetcode中的斐波那契数列差不多，只不过这个题目要求是之前3项的和，操作是一样的。 1234567891011121314class Solution: def tribonacci(self, n: int) -&gt; int: if n == 0: return 0 if n == 1: return 1 if n == 2: return 1 dp = [0] * (n + 1) dp[1] = 1 dp[2] = 1 for i in range(3, len(dp)): dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1] return dp[-1] LeetCode 1138 Alphabet Board Path原题链接 12345678910111213141516171819202122232425262728293031323334On an alphabet board, we start at position (0, 0), corresponding to character board[0][0].Here, board = [&quot;abcde&quot;, &quot;fghij&quot;, &quot;klmno&quot;, &quot;pqrst&quot;, &quot;uvwxy&quot;, &quot;z&quot;], as shown in the diagram below.We may make the following moves:&apos;U&apos; moves our position up one row, if the position exists on the board;&apos;D&apos; moves our position down one row, if the position exists on the board;&apos;L&apos; moves our position left one column, if the position exists on the board;&apos;R&apos; moves our position right one column, if the position exists on the board;&apos;!&apos; adds the character board[r][c] at our current position (r, c) to the answer.(Here, the only positions that exist on the board are positions with letters on them.)Return a sequence of moves that makes our answer equal to target in the minimum number of moves. You may return any path that does so. Example 1:Input: target = &quot;leet&quot;Output: &quot;DDR!UURRR!!DDD!&quot;Example 2:Input: target = &quot;code&quot;Output: &quot;RR!DDRR!UUL!R!&quot; Constraints:1 &lt;= target.length &lt;= 100target consists only of English lowercase letters. 题目大意：在一个全都是字母的矩阵中，找出一条路径，要求这个路径按顺序经过target字符串中所有的字母。 这道题感觉比较容易，唯一的陷阱（我是踩进去了），就是z这个字母，我们要想去找去z的路径，必须先往左走，然后再往下走。如果先往下扫描就有可能 超出矩阵范围。 123456789101112131415161718192021222324252627282930313233class Solution: def alphabetBoardPath(self, target: str) -&gt; str: board = [&quot;abcde&quot;, &quot;fghij&quot;, &quot;klmno&quot;, &quot;pqrst&quot;, &quot;uvwxy&quot;] dic = &#123;&#125; for i in range(len(board)): for j in range(5): dic[board[i][j]] = [i, j] dic[&apos;z&apos;] = (5, 0) i = 0 start = [0, 0] res = &quot;&quot; while i &lt; len(target): if start == dic[target[i]]: res += &apos;!&apos; else: if target[i] == &apos;z&apos;: res += &apos;L&apos; * (start[1] - 0) + &apos;D&apos; * (5 - start[0]) res += &apos;!&apos; start = [5, 0] else: end = dic[target[i]] if start[0] &gt; end[0]: res += &apos;U&apos; * (start[0] - end[0]) elif start[0] &lt; end[0]: res += &apos;D&apos; * (end[0] - start[0]) if start[1] &gt; end[1]: res += &apos;L&apos; * (start[1] - end[1]) elif start[1] &lt; end[1]: res += &apos;R&apos; * (end[1] - start[1]) res += &apos;!&apos; start = end i += 1 return res LeetCode 1139 Largest 1-Bordered Square原题链接 123456789101112131415161718192021Given a 2D grid of 0s and 1s, return the number of elements in the largest square subgrid that has all 1s on its border, or 0 if such a subgrid doesn&apos;t exist in the grid. Example 1:Input: grid = [[1,1,1],[1,0,1],[1,1,1]]Output: 9Example 2:Input: grid = [[1,1,0,0]]Output: 1 Constraints:1 &lt;= grid.length &lt;= 1001 &lt;= grid[0].length &lt;= 100grid[i][j] is 0 or 1 题目大意：在一个全是0和1的矩阵中找一个最大的正方形，要求这个正方形的4条边全都是1。 这个题目类型其实在LeetCode中有很多类似的题目： LeetCode 221LeetCode 85 核心思想就是将连续的1叠加在一起，通过搜索得出答案。那么这个题目我们需要确定一个正方形是否符合要求，需要扫描两个方向，一个是横行，一个 竖行，这2个方向4条边是否全都是1。那么我们需要两个矩阵来分别预处理这两个方向。 123456789101112131415161718example: 1, 1, 1 1, 0, 1 1, 1, 1根据上面的例子，预处理两个方向的矩阵： 横向： 1， 2， 3 1， 0， 1 1， 2， 3 竖向： 1， 1， 1 2， 0， 2 3， 1， 3假设最大的边长为r, 我们根据这个边长来进行扫描整个数组，假设扫描到一个点grid[i][j]，我们根据这个点来判断是否是一个合法正方形，我们需要判断4个条件，横向矩阵中row[i][j + r - 1] 和 row[i + r - 1][j + r - 1] 是否都是大于或者等于r, 并且在竖向矩阵中 col[i + r - 1][j]和col[i + r - 1][j + r - 1]是否都大于等于r。满足这4个条件说明这是一个至少边长为r的正方形。返回r ** 2的平方即可。 1234567891011121314151617class Solution: def largest1BorderedSquare(self, grid: List[List[int]]) -&gt; int: row = [i[:] for i in grid] col = [i[:] for i in grid] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: if i: row[i][j] = row[i - 1][j] + 1 if j: col[i][j] = col[i][j - 1] + 1 for l in range(min(len(grid), len(grid[0])), 0, -1): for i in range(len(grid) - l + 1): for j in range(len(grid[0]) - l + 1): if row[i + l - 1][j + l - 1] &gt;= l and row[i + l - 1][j] &gt;= l and col[i + l - 1][j + l - 1] &gt;= l and col[i][j + l - 1] &gt;= l: return l ** 2 return 0 LeetCode 1140 Stone Game II原题链接 1234567891011121314151617181920212223242526Alex and Lee continue their games with piles of stones. There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones. Alex and Lee take turns, with Alex starting first. Initially, M = 1.On each player&apos;s turn, that player can take all the stones in the first X remaining piles, where 1 &lt;= X &lt;= 2M. Then, we &apos; + &apos;set M = max(M, X).The game continues until all the stones have been taken.Assuming Alex and Lee play optimally, return the maximum number of stones Alex can get. Example 1:Input: piles = [2,7,9,4,4]Output: 10Explanation: If Alex takes one pile at the beginning, Lee takes two piles, then Alex takes 2 piles again. Alex can get 2 + 4 + 4 = 10 piles in total. If Alex takes two piles at the beginning, then Lee can take all three piles left. In this case, Alex get 2 + 7 = 9 piles in total. So we return 10 since it&apos;s larger. Constraints:1 &lt;= piles.length &lt;= 1001 &lt;= piles[i] &lt;= 10 ^ 4 题目大意：两个人拿石头，求当两个人都完美发挥的时候，Alex能获得多少石头。 这个题目是一个比较明显的记忆化递归的题目。 123 0 -------k--------len(arr)假设Alex先取前k堆个石头，那么他最后将获得多少石头？我们需要继续进行递归搜索在k到len(arr)这个区间内进行递归，最后退栈的时候返回最大值就是最优解。其中需要用到记忆化，来降低时间复杂度，避免遇到重复的状态时，继续进行递归索索。 1234567891011121314151617181920class Solution: def stoneGameII(self, piles: List[int]) -&gt; int: memo = &#123;&#125; weight = [0] for i in range(len(piles)): weight += [weight[-1] + piles[-1 - i]] weight.reverse() weight.pop() def dp(i, m): # i代表当前数组的位置， m代表可选择多少堆石头的区间，用(i, m)作为状态，并保存起来。 if (i, m) not in memo: if len(piles) - i &lt;= 2 * m: memo[(i, m)] = weight[i] else: temp = 0 for k in range(1, 2 * m + 1): newm = max(m, k) temp = max(temp, weight[i] - dp(i + k, newm)) memo[(i, m)] = temp return memo[(i, m)] return dp(0, 1)]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Biweekly Contest 5]]></title>
    <url>%2F2019%2F07%2F27%2Fbiweekly5%2F</url>
    <content type="text"><![CDATA[LeetCode 1133 Largest Unique Number原题链接 123456789101112131415161718192021222324Given an array of integers A, return the largest integer that only occurs once.If no integer occurs once, return -1. Example 1:Input: [5,7,3,9,4,9,8,3,1]Output: 8Explanation: The maximum integer in the array is 9 but it is repeated. The number 8 occurs only once, so it&apos;s the answer.Example 2:Input: [9,9,8,8]Output: -1Explanation: There is no number that occurs only once. Note:1 &lt;= A.length &lt;= 20000 &lt;= A[i] &lt;= 1000 题目大意：从数组中找出最大数字，并且这个数字在数组中是唯一的。没什么好说的，用字典存储数组中个元素出现的次数，然后从次数为1的元素中 找出最大值。 12345678910class Solution: def largestUniqueNumber(self, A: List[int]) -&gt; int: count = collections.Counter(A) num = [] for key in count: if count[key] == 1: num.append(key) if not num: return -1 return max(num) LeetCode 1134 Armstrong Number原题链接 123456789101112131415161718192021222324The k-digit number N is an Armstrong number if and only if the k-th power of each digit sums to N.Given a positive integer N, return true if and only if it is an Armstrong number. Example 1:Input: 153Output: trueExplanation: 153 is a 3-digit number, and 153 = 1^3 + 5^3 + 3^3.Example 2:Input: 123Output: falseExplanation: 123 is a 3-digit number, and 123 != 1^3 + 2^3 + 3^3 = 36. Note:1 &lt;= N &lt;= 10^8 题目大意：对一个数字中的每一位数字进行整个数字的长度的指数次处理，然后求和。 123456789class Solution: def isArmstrong(self, N: int) -&gt; bool: d = len(str(N)) n = N res = 0 while N: res += (N % 10) ** d N = N // 10 return res == n LeetCode 1135 Connecting Cities With Minimum Cost原题链接 1234567891011121314151617181920212223242526272829303132333435363738There are N cities numbered from 1 to N.You are given connections, where each connections[i] = [city1, city2, cost] represents the cost to connect city1 and city2 together. (A connection is bidirectional: connecting city1 and city2 is the same as connecting city2 and city1.)Return the minimum cost so that for every pair of cities, there exists a path of connections (possibly of length 1) that connects those two cities together. The cost is the sum of the connection costs used. If the task is impossible, return -1. Example 1:Input: N = 3, connections = [[1,2,5],[1,3,6],[2,3,1]]Output: 6Explanation: Choosing any 2 edges will connect all cities so we choose the minimum 2.Example 2:Input: N = 4, connections = [[1,2,3],[3,4,4]]Output: -1Explanation: There is no way to connect all cities even if all edges are used. Note:1 &lt;= N &lt;= 100001 &lt;= connections.length &lt;= 100001 &lt;= connections[i][0], connections[i][1] &lt;= N0 &lt;= connections[i][2] &lt;= 10^5connections[i][0] != connections[i][1] 题目大意：在一个无向图中，找出一个最短路径，要求这个路径要经过每一个节点。 这道题在周赛出没做出来，因为有一部分实在无法证明。后来发现这题是一个典型的例题叫做MST(Minimum Spanning Tree),有两种算法都可以解决 这个问题。只要知道其中一种算法，这道题其实是一道非常容易的题。在这篇blog中，就不做数学上的证明了，简单介绍一下算法的原理。 Kruskal算法： 这个算法其实本质是一个贪心性质的算法，首先将数组排序，根据路径长度进行排序。然后开始遍历数组。在遍历的过程中我们需要使用Union Find 来处理已经遍历过的节点，因为如果出现两个节点的根节点是相同的，我们就没有必要在处理这两个节点，因为前面的图已经经过这两个节点，并且路径 一定比当前的短，因为我们将数组预处理过（按照路径长度）。最后我们只需要判断这个图是否经过了所有的节点即可。 12345678910111213141516171819202122class Solution: def minimumCost(self, N: int, connections: List[List[int]]) -&gt; int: def find(x): parents.setdefault(x, x) if x != parents[x]: parents[x] = find(parents[x]) return parents[x] def union(x, y): parents[find(x)] = find(y) res = 0 parents = &#123;&#125; for x, y, cost in sorted(connections, key=lambda x: x[2]): if find(x) != find(y): res += cost union(x, y) if len(&#123;find(x) for x in range(1, N+1)&#125;) != 1: return -1 else: return res Prim算法： 这个算法的本质是，选取任意一个节点作为起始点，然后根据这个起点能连接到所有节点入堆，堆排序根据路径长度来排序，所以保证每一次处理的路径 都是当前最短的路径，直到堆为空。在这个过程中不断叠加路径的总和，最后判断所有节点是否都扫描过即可。 1234567891011121314151617181920212223class Solution: def minimumCost(self, N: int, connections: List[List[int]]) -&gt; int: if len(connections) &lt; N - 1: return -1 dic = collections.defaultdict(list) for c in connections: dic[c[0]].append([c[1], c[2]]) dic[c[1]].append([c[0], c[2]]) heap = [(0, 1)] seen = [False] * (N + 1) seen[0] = True res = 0 while heap: cost, node = heapq.heappop(heap) if seen[node]: continue res += cost seen[node] = True for n, c in dic[node]: heapq.heappush(heap,[c, n]) if False in seen: return -1 return res LeetCode 1136 Parallel Courses原题链接 12345678910111213141516171819202122232425262728293031323334353637383940There are N courses, labelled from 1 to N.We are given relations[i] = [X, Y], representing a prerequisite relationship between course X and course Y: course X has to be studied before course Y.In one semester you can study any number of courses as long as you have studied all the prerequisites for the course you are studying.Return the minimum number of semesters needed to study all courses. If there is no way to study all the courses, return -1. Example 1:Input: N = 3, relations = [[1,3],[2,3]]Output: 2Explanation: In the first semester, courses 1 and 2 are studied. In the second semester, course 3 is studied.Example 2:Input: N = 3, relations = [[1,2],[2,3],[3,1]]Output: -1Explanation: No course can be studied because they depend on each other. Note:1 &lt;= N &lt;= 50001 &lt;= relations.length &lt;= 5000relations[i][0] != relations[i][1]There are no repeated relations in the input. 题目大意：有一个课程表，里面包括每一个课程所需的前置课程，要求我们求出最少需要多少轮的学习才可以完成所有课程。 这道题和LeetCode 210, 207差不多。主要涉及到一种特殊的算法叫做拓普排序（Topological Sort)。简单来说这个排序的实际作用就是找环。 因为在搜索过程中发现所有课程中存在一个环，那么说明一定有一部分的课程是无法完成的（例如[(1, 2), (2, 3), (3, 1)],学习2必须先学1， 学习3必须先学2，学习1必须先学习3，那么这其中就形成了一个死环，这三门课程都无法完成。所以这道题的基本思路就出来了，首先判断是否能完成 所有课程，然后用DFS来搜索查找一个最大的周期就是答案。 LeetCode 207LeetCode 210 1234567891011121314151617181920212223242526272829303132333435class Solution: def minimumSemesters(self, N: int, relations: List[List[int]]) -&gt; int: seen = [0] * (N + 1) dic = collections.defaultdict(list) for r in relations: dic[r[1]].append(r[0]) def dfs(node, count): if seen[node] == 1: return True if seen[node] == -1: return False seen[node] = -1 for n in dic[node]: if not dfs(n, count + 1): return False seen[node] = 1 return True dic1 = &#123;&#125; def count(node): if node in dic1: return dic1[node] temp = [] for n in dic[node]: cnt = count(n) temp.append(cnt) res = 1 + max(temp) if temp else 1 dic1[node] = res return res for node in range(1, N + 1): if not dfs(node, 1): return -1 self.res = 0 for node in range(1, N + 1): self.res = max(self.res, count(node)) return self.res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 959 Regions Cut By Slashes]]></title>
    <url>%2F2019%2F07%2F26%2F959%2F</url>
    <content type="text"><![CDATA[LeetCode 959 Regions Cut By Slashes原题链接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859In a N x N grid composed of 1 x 1 squares, each 1 x 1 square consists of a /, \, or blank space. These characters divide the square into contiguous regions.(Note that backslash characters are escaped, so a \ is represented as &quot;\\&quot;.)Return the number of regions. Example 1:Input:[ &quot; /&quot;, &quot;/ &quot;]Output: 2Explanation: The 2x2 grid is as follows:Example 2:Input:[ &quot; /&quot;, &quot; &quot;]Output: 1Explanation: The 2x2 grid is as follows:Example 3:Input:[ &quot;\\/&quot;, &quot;/\\&quot;]Output: 4Explanation: (Recall that because \ characters are escaped, &quot;\\/&quot; refers to \/, and &quot;/\\&quot; refers to /\.)The 2x2 grid is as follows:Example 4:Input:[ &quot;/\\&quot;, &quot;\\/&quot;]Output: 5Explanation: (Recall that because \ characters are escaped, &quot;/\\&quot; refers to /\, and &quot;\\/&quot; refers to \/.)The 2x2 grid is as follows:Example 5:Input:[ &quot;//&quot;, &quot;/ &quot;]Output: 3Explanation: The 2x2 grid is as follows: 题目大意：在一个正方形中进行分割，求分割后有多少个区域。 这个题目其实不是很难，但是不太容易理解。在每一个1 * 1的正方形中存在一个正对角线或者反对角线。其实这个题目我们只需要考虑每一个1 * 1的 正方形就可以。 上面的图，展示了一个2 * 2的正方形，那么每一个1 * 1的小正方形中可以存在4个可能的区域，假如是&apos;/&apos;这样的对角线区域0和区域1是相互连接的， 区域2和区域3是相互连接的；假如是&apos;\&apos;， 区域0， 2 相连接，区域1,3相连接。与此同时两个相邻的小正方形一定有两个相互连接的区域，例如水平 方向，正方形1的区域2和正方形2的区域1，和竖直方向正方形1的区域3和正方形3的区域0。这么分析完这道题，其实可以发现这是一个非常明显的并查 集的思想。可以用(i, j, x)来表示每一个小区域的状态，i表示横坐标，j表示纵坐标，x表示正方形内的区域。完成整个并查集之后，我们只需要统计 有多少个根节点即可。 12345678910111213141516171819202122232425262728293031class UnionFind: def __init__(self): self.parent = &#123;&#125; def find(self, x): if x not in self.parent: self.parent[x] = x if x != self.parent[x]: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): self.parent[self.find(x)] = self.find(y)class Solution: def regionsBySlashes(self, grid: List[str]) -&gt; int: uf = UnionFind() for i in range(len(grid)): for j in range(len(grid)): if i: uf.union((i - 1, j, 2), (i, j, 0)) if j: uf.union((i, j - 1, 1), (i, j, 3)) if grid[i][j] != &apos;/&apos;: uf.union((i, j, 0), (i, j, 1)) uf.union((i, j, 2), (i, j, 3)) if grid[i][j] != &apos;\\&apos;: uf.union((i, j, 3), (i, j, 0)) uf.union((i, j, 1), (i, j, 2)) res = 0 for key in uf.parent: if key == uf.find(key): res += 1 return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 318 Maximum Product of Word Lengths]]></title>
    <url>%2F2019%2F07%2F24%2F318%2F</url>
    <content type="text"><![CDATA[LeetCode 318 Maximum Product of Word Lengths原题链接 1234567891011121314151617181920Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.Example 1:Input: [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]Output: 16 Explanation: The two words can be &quot;abcw&quot;, &quot;xtfn&quot;.Example 2:Input: [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]Output: 4 Explanation: The two words can be &quot;ab&quot;, &quot;cd&quot;.Example 3:Input: [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]Output: 0 Explanation: No such pair of words. 题目大意：求数组中，两个字符串长度的最大乘积，要求这两个字符串没有重复的部分。 暴力搜索来解这道题没什么意思，也无法AC全部case。因为每一次搜索都需要针对两个字符串进行扫描，数组长度越大，时间复杂度会越高，指数增长。 我记得在之前的一篇DP文章中介绍过状态压缩这个概念，其实运用到这个题目中非常合适。对于一个全部小写的字符串，一共就有26个状态,然而作为 一个字符串他的长度可以无限长，完全可以用一个最大26位的二进制整型数字来存储这个状态。 1234567example: &apos;abcd&apos;例如&apos;abcd&apos;，我们需要扫描一下整个数组，起始状态是mask = 0,首先我们扫描到的字符是&apos;a&apos;，那么a应该是ord(&apos;a&apos;) - ord(&apos;a&apos;)这个位置，那么更新mask， mask |= 1 &lt;&lt; (ord(&apos;a&apos;) - ord(&apos;a&apos;)),然后继续扫描，直到扫描完成。最终这个字符串的状态应该为1111，转换为整型数字就是15，用15来表示这个字符串的状态，然后将这个状态存入到字典中，该状态对应的元素应该是数组中对应这个状态的字符串长度的最大值。扫描完整个数组，我们只需要重新对字典进行两重循环遍历就可以找到答案。例如第二个字符串的状态是x，那么如果要判断是否与第一个字符串有重叠部分，只需要进行15 &amp; x,如果结果是0，说明这两个字符串没有重叠部分。这样这个题目就非常的简单了。 1234567891011121314class Solution: def maxProduct(self, words: List[str]) -&gt; int: dic = collections.defaultdict(int) for word in words: # 进行状态压缩，然后将所有状态对应的字符串长度存入字典。 mask = 0 for char in word: mask |= 1 &lt;&lt; (ord(char) - ord(&apos;a&apos;)) dic[mask] = max(dic.get(mask, 0), len(word)) res = 0 for i in dic: #针对字典里的元素进行遍历，寻找最大值。 for j in dic: if not i &amp; j: res = max(res, dic[i] * dic[j]) return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 312, 1039, 1130]]></title>
    <url>%2F2019%2F07%2F21%2Fleetcode312-1039-1130%2F</url>
    <content type="text"><![CDATA[LeetCode 312 Burst Balloons原题链接 123456789101112131415Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.Find the maximum coins you can collect by bursting the balloons wisely.Note:You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100Example:Input: [3,1,5,8]Output: 167 Explanation: nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 题目大意：打气球的游戏，每打破一个气球，将会得到这个气球乘以他两边气球的分数，求出最多能得多少分。 这种题目如果用暴力搜索来做，非常的不现实，时间复杂度太高，所以需要用dp来解决这个问题，将其转化成一些小的问题来解决大的问题。 12345678910111213刚开始看这道题感觉没什么思路，不知道从何下手，但是按照leetcode的规矩，好像这种hard题做暴力解法肯定是不行的。换一个角度来思考这个问题，我们假设某一个气球是最后一个打破的，看下面的例子。example: 0------------k-----------len(arr)从数组中寻找一个位置，例如位置k，假设这个最后一个打破的气球是k这个位置的气球能使得得分最高，那么这道题就变成了0到k位置这个区间的最大得分，加上k到末尾这个区间的最大得分，和最后打破k位置气球的得分。那么我们只要继续解决0-k和k到末尾这两个区间的子问题就可以得到最优解，那么状态转移方程就出来了。dp[l][r] = dp[l][k - 1] + dp[k + 1][r] + nums[k] * nums[l] * nums[r]那么这道题dp中最难解决的部分出来了，接下来就是代码。至于怎么找到这个k，其实我们可以看成是分割的问题，假设数组长度是n，我们可以用一个循环假设左半部分的长度是l，右半部分就是n - l，这样中间的位置就找出了，至于是不是最优解，我们需要继续进行循环去搜索。 123456789101112class Solution: def maxCoins(self, nums: List[int]) -&gt; int: nums = [1] + nums + [1] # 在数组头尾分别加上1，方便操作。 dp = [[0 for _ in range(len(nums))] for _ in range(len(nums))] #初始化DP数组 for d in range(2, len(nums)): #设置一个gap， 根据gap来做循环。 for l in range(0, len(nums) - d): # 设置左边的起点，来对数组的各个区间来搜索最大值。 r = l + d for k in range(l + 1, r): # 在区间中找一个位置，使得该区间的得分最大 dp[l][r] = max(dp[l][r], dp[l][k] + dp[k][r] + nums[k] * nums[l] * nums[r]) print(dp) return dp[0][-1]# dp[l][r]的意义就是区间从l到r的最大得分，那么解析完整个dp数组，返回dp[0][-1]即可 LeetCode 1039 Minimum Score Triangulation of Polygon原题链接 12345678910111213141516171819202122232425262728293031323334Given N, consider a convex N-sided polygon with vertices labelled A[0], A[i], ..., A[N-1] in clockwise order.Suppose you triangulate the polygon into N-2 triangles. For each triangle, the value of that triangle is the product ofthe labels of the vertices, and the total score of the triangulation is the sum of these values over all N-2 triangles in the triangulation.Return the smallest possible total score that you can achieve with some triangulation of the polygon. Example 1:Input: [1,2,3]Output: 6Explanation: The polygon is already triangulated, and the score of the only triangle is 6.Example 2:Input: [3,7,4,5]Output: 144Explanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144. The minimum score is 144.Example 3:Input: [1,3,1,4,1,5]Output: 13Explanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13. Note:3 &lt;= A.length &lt;= 501 &lt;= A[i] &lt;= 100 题目大意：在一个多边形中，三点构成一个三角形（可以得到三个点乘积的分数），问如何分割多边形使得最后得分最大。 其实这道题和LeetCode 312 是一样的，只是很容易被这个图误导。实际上就是找出其中一个三角形，使得这个三角形的得分加上他两边多边形的得分 使得总分最大。还是一个分割的问题，所以依旧是上个题的模板，只不过题目描述不一样，代码几乎都是一样的。 12345678910class Solution: def minScoreTriangulation(self, A: List[int]) -&gt; int: dp = [[0 for _ in range(len(A))] for _ in range(len(A))] for d in range(2, len(A)): for l in range(0, len(A) - d): r = l + d dp[l][r] = float(&apos;inf&apos;) for k in range(l + 1, r): dp[l][r] = min(dp[l][r], dp[l][k] + dp[k][r] + A[l] * A[r] * A[k]) return dp[0][-1] 这道题的做法还是区间分割，要对每个区间进行最大值解析，最后求出总区间（dp[0][-1]）的最大值，因为三点构成一个三角形，所以我们在区间内 找到一个点，构成一个三角形，然后不断更新当前区间的最大值就可以了。 LeetCode 1130 Minimum Cost Tree From Leaf Values原题链接 123456789101112131415161718192021222324252627282930Given an array arr of positive integers, consider all binary trees such that:Each node has either 0 or 2 children;The values of arr correspond to the values of each leaf in an in-order traversal of the tree. (Recall that a node is a leaf if and only if it has 0 children.)The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree respectively.Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node. It is guaranteed this sum fits into a 32-bit integer. Example 1:Input: arr = [6,2,4]Output: 32Explanation:There are two possible trees. The first has non-leaf node sum 36, and the second has non-leaf node sum 32. 24 24 / \ / \ 12 4 6 8 / \ / \6 2 2 4 Constraints:2 &lt;= arr.length &lt;= 401 &lt;= arr[i] &lt;= 15It is guaranteed that the answer fits into a 32-bit signed integer (ie. it is less than 2^31). 题目大意：题目给出一个数组，数组是一个二叉树的叶子，并且是按照顺序排序的，每个父节点都是他的左右子树的最大叶子节点的值的乘积。要求我 门求出二叉树中除了叶子以为所有节点和的最大值。 这是LeetCode Weekley Contest 146期的第三题，这道题实际上也是一个分割的问题，起初想着构建一个二叉树，但是这种方法不太可行，我们只 需要将数组分割成不同的区间，每个区间保存着最大叶子值，只要用两个区间中叶子最大值的乘积就是父节点的值了。最后可以得出最大的结果。本质 意义上其实是和前面的问题是一样的，分割区间求最值。 1234567891011121314class Solution: def mctFromLeafValues(self, arr: List[int]) -&gt; int: maxval = [[float(&apos;-inf&apos;) for _ in range(len(arr) + 1)] for _ in range(len(arr) + 1)] for i in range(len(arr)): for j in range(i, len(arr)): maxval[i][j + 1] = max(maxval[i][j], arr[j]) dp = [[0 for _ in range(len(arr) + 1)] for _ in range(len(arr) + 1)] for gap in range(2, len(arr) + 1): for l in range(len(arr) - gap + 1): r = l + gap dp[l][r] = float(&apos;inf&apos;) for k in range(l + 1, r): dp[l][r] = min(dp[l][r], dp[l][k] + dp[k][r] + maxval[l][k] * maxval[k][r]) return dp[0][len(arr)] 这道题目唯一需要多处理的地方就是，在处理dp矩阵之前，我们需要先预处理一个矩阵，矩阵的row和col代表这个区间的最大值，方便后面的搜索。 这是一个很直观的答案，但是看了Lee的做法，这道题还有一种更好的解法。 Lee215-Time-and-Space) 12345678910111213Find the cost for the interval [i,j].To build up the interval [i,j],we need to split it into left subtree and sub tree,dp[i, j] = dp[i, k] + dp[k + 1, j] + max(A[i, k]) * max(A[k + 1, j])This solution is O(N^3) time and O(N^2) space. You think it&apos;s fine.After several nested for loop, you get a green accepted and release a sigh.Great practice for DP!Then you think that&apos;s it for a medium problem, nothing can stop you.so you didn&apos;t read and up-vote my post.One day, you bring this solution to an interview and probably fail. 这是他对这道题的评价，面试的时候碰到这种题我反正是认为这个dp的解法是足够了- - 123456789101112131415161718When we build a node in the tree, we compared the two numbers a and b.In this process,the smaller one is removed and we won&apos;t use it anymore,and the bigger one actually stays.The problem can translated as following:Given an array A, choose two neighbors in the array a and b,we can remove the smaller one min(a,b) and the cost is a * b.What is the minimum cost to remove the whole array until only one left?To remove a number a, it needs a cost a * b, where b &gt;= a.So a has to be removed by a bigger number.We want minimize this cost, so we need to minimize b.b has two candidates, the first bigger number on the left,the first bigger number on the right.The cost to remove a is a * min(left, right). 他认为这道题其实就是数组中两个相邻数字的乘积，我们需要用一个栈来保存每一个数字，新遍历出来的数字如果大于等于栈中最后一个数字，那么这 时候需要把栈中最后一个元素pop出来，乘以当前栈中最后一个元素，这样可以保证这样的二叉树父节点的值最小。这种方法只需要遍历一遍数组就可以 找出最优解，确实比DP好很多，但是确实不太好想，Lee这个人很厉害，很多题的解法都非常的优秀，但是确实不容易在第一时间想出来。 123456789101112class Solution: def mctFromLeafValues(self, arr: List[int]) -&gt; int: res = 0 stack = [float(&apos;inf&apos;)] for num in arr: while stack[-1] &lt;= num: mid = stack.pop() res += mid * min(stack[-1], num) stack.append(num) while len(stack) &gt; 2: res += stack.pop() * stack[-1] return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Weekly Contest 146]]></title>
    <url>%2F2019%2F07%2F21%2FContest146%2F</url>
    <content type="text"><![CDATA[LeetCode 1128 Number of Equivalent Domino Pairs原题链接 1234567891011Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a==c and b==d), or (a==d and b==c) - that is, one domino can be rotated to be equal to another domino.Return the number of pairs (i, j) for which 0 &lt;= i &lt; j &lt; dominoes.length, and dominoes[i] is equivalent to dominoes[j]. Example 1:Input: dominoes = [[1,2],[2,1],[3,4],[5,6]]Output: 1 这道题没什么好说的，就是找相同的组合([1, 2] = [2, 1])，用字典存一下之前有多少个相同的组合，遍历数组即可。 12345678910class Solution: def numEquivDominoPairs(self, dominoes: List[List[int]]) -&gt; int: res = 0 dic = collections.defaultdict(int) for d in dominoes: d = sorted(d) if tuple(d) in dic: res += dic[tuple(d)] dic[tuple(d)] += 1 return res LeetCode 1129 Shortest Path with Alternating Colors原题链接 1234567891011121314151617181920212223242526272829303132333435363738394041Consider a directed graph, with nodes labelled 0, 1, ..., n-1. In this graph, each edge is either red or blue, and there could be self-edges or parallel edges.Each [i, j] in red_edges denotes a red directed edge from node i to node j. Similarly, each [i, j] in blue_edges denotes a blue directed edge from node i to node j.Return an array answer of length n, where each answer[X] is the length of the shortest path from node 0 to node X such that the edge colors alternate along the path (or -1 if such a path doesn&apos;t exist). Example 1:Input: n = 3, red_edges = [[0,1],[1,2]], blue_edges = []Output: [0,1,-1]Example 2:Input: n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]Output: [0,1,-1]Example 3:Input: n = 3, red_edges = [[1,0]], blue_edges = [[2,1]]Output: [0,-1,-1]Example 4:Input: n = 3, red_edges = [[0,1]], blue_edges = [[1,2]]Output: [0,1,2]Example 5:Input: n = 3, red_edges = [[0,1],[0,2]], blue_edges = [[1,0]]Output: [0,1,1] Constraints:1 &lt;= n &lt;= 100red_edges.length &lt;= 400blue_edges.length &lt;= 400red_edges[i].length == blue_edges[i].length == 20 &lt;= red_edges[i][j], blue_edges[i][j] &lt; n 题目大意：这是一个有向图，每两个连接节点的边都是有特定的颜色，要求我们计算从节点0到每一个节点的最短距离，并且要求每一条路径必须是红色 和蓝色相间才算是合法路径。 对于图的问题无外乎几种方法，深度优先搜索(DFS), 广度优先搜索(BFS),并查集(Union Find),这是几种比较常用的方法，当然还有一些其他的。 这道题要求我们求最短路径，感觉用BFS的方法可能会比较好。首先我们需要用两个字典分别保存红蓝路径，方便后面查找。在搜索的过程中，我们需要 3个状态，分别是距离，节点和颜色，初始的状态是从节点0开始的，每一次搜索，如果还存在新路径，将其添加到队列中。直到所有状态搜索完毕，我 们还需要一个集合来保存状态，如果这个状态搜索过，我们直接忽略这个状态即可，防止程序进入死循环。 12345678910111213141516171819202122232425262728class Solution: def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -&gt; List[int]: res = [float(&apos;inf&apos;)] * n dicr = collections.defaultdict(list) dicb = collections.defaultdict(list) for r in red_edges: dicr[r[0]].append(r[1]) for b in blue_edges: dicb[b[0]].append(b[1]) stack = collections.deque() stack.append((0, 0, 0)) seen = set() while stack: d, n, c = stack.popleft() seen.add((n, c)) res[n] = min(res[n], d) if c == 0 or c == 2: for node in dicr[n]: if (node, 1) not in seen: stack.append((d + 1, node, 1)) if c == 0 or c == 1: for node in dicb[n]: if (node, 2) not in seen: stack.append((d + 1, node, 2)) for i in range(len(res)): if res[i] == float(&apos;inf&apos;): res[i] = -1 return res LeetCode 1130 Minimum Cost Tree From Leaf Values这道题目我会另起一个文章，和几个类似的题目一起解析。 LeetCode 1131 Maximum of Absolute Value Expression原题链接 1234567891011121314151617181920212223Given two arrays of integers with equal lengths, return the maximum value of:|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|where the maximum is taken over all 0 &lt;= i, j &lt; arr1.length. Example 1:Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]Output: 13Example 2:Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]Output: 20 Constraints:2 &lt;= arr1.length == arr2.length &lt;= 40000-10^6 &lt;= arr1[i], arr2[i] &lt;= 10^6Accepted 题目大意：要求从两个数组中分别找出两组值，带入到上述的函数中，求出最大值。 考试的时候在第三题花费的时间比较长，这道题目当时考试的时候没做出来，但是这道题目还是挺有意思的。两个数组的问题，看了下数据规模，最大 规模可以达到40000的长度，那么Brute Force根本就不用去想。这道题的考点其实就是如何来拆掉这个函数中的绝对值。 12345678910111213function： |a1 - b1| + |a2 - b2| + |i - j|对于|a1 - b1| 可以转换成两种状态[[a1 - b1], [b1 - a1]]对于|a2 - b2| 同样可以转换成[[a2 - b2], [b2 - a2]]|i - j| 我们可以不用考虑绝对值，因为我们可以按照索引进行遍历就可以了。那么这么个函数相当于有4种状态：(a1 - b1) + (a2 - b2) =&gt; (a1 + a2) - (b1 + b2)(b1 - a1) + (a2 - b2) =&gt; (-a1 + a2) - (-b1 + b2)(a1 - b1) + (b2 - a2) =&gt; (a1 - a2) - (b1 - b2)(b1 - a1) + (b2 - a2) =&gt; (-a1 - a2) - (-b1 - b2)这4个例子的最大值，就是函数的值，实际上就是4种状态(+, +), (-, -), (+, -), (-, +)如果我们直接用abs()这个函数来求解这个问题，我们不可能在遍历过程中直接找到一个最小值，所以时间复杂度为O(n ** n)去掉绝对值，我们直接按照索引去遍历一次数组就够了，在遍历的过程中随时更新最小值，然后用当前状态减去最小值就可以得到答案。 12345678910class Solution: def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -&gt; int: res = 0 for p, q in [(1, 1), (-1, 1), (-1, -1), (1, -1)]: minval = p * arr1[0] + q * arr2[0] + 0 for i in range(len(arr1)): cur = p * arr1[i] + q * arr2[i] + i res = max(res, cur - minval) minval = min(minval, cur) return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 60 Permutation Sequence]]></title>
    <url>%2F2019%2F07%2F18%2Fleetcode60%2F</url>
    <content type="text"><![CDATA[LeetCode 60 Permutation Sequence原题链接 1234567891011121314151617181920212223242526The set [1,2,3,...,n] contains a total of n! unique permutations.By listing and labeling all of the permutations in order, we get the following sequence for n = 3:&quot;123&quot;&quot;132&quot;&quot;213&quot;&quot;231&quot;&quot;312&quot;&quot;321&quot;Given n and k, return the kth permutation sequence.Note:Given n will be between 1 and 9 inclusive.Given k will be between 1 and n! inclusive.Example 1:Input: n = 3, k = 3Output: &quot;213&quot;Example 2:Input: n = 4, k = 9Output: &quot;2314&quot; 题目大意：从一个全排列中找第k大的数字。 这道题是一道很有意思的题目，有一个很巧妙的方法。一眼看上去，第一感觉就是用backtrack找出全排列，然后排序找答案。但是这个方法在LeetCode 中无法AC，可能是Python3的缘故，其他语言不知道- -。很明显出题人不想让大家用这种方式解决这个问题。我来解释一下这个巧妙的方法。 1234567891011121314151617181920就用题目中给出的例子：n = 3， k = 3.那么在这个例子中的全排列就是：123132----213231----312321首先这个全排列的数量是n！。看上面的例子，可以将其分为n组，每一组都有两个数字，那么在第一次循环中，我们需要判断这个数字属于第几组。题目要求为k，2个数字构成一组，那么3//2 = 1也就是说我们要找的数字在第二组中，换个说法就是我们找到了第一个位置的数字2。那么接下来，我们需要在下面的数字中搜索：13---31k在第一搜索中就变成k % 2 = 1,上面的新全排列中只有两组，因为我们确定了第一位的数字是2，重复上述的操作，我们会找到第二位数字是1，那么剩下最后一个数字就是3了，答案就出来了。 12345678910111213141516class Solution: def getPermutation(self, n: int, k: int) -&gt; str: res = &quot;&quot; nums = [] for i in range(1, 10): nums.append(str(i)) fact = [1] * n for i in range(1, n): # 构建一个数组，每个位置有多少种数字构成 fact[i] = i * fact[i - 1] k -= 1 for i in range(n, 0, - 1): cur = k // fact[i - 1] # 当前位置是哪个数字 k %= fact[i - 1] res += nums[cur] nums.pop(cur) # 除掉当前位置的数字，因为题目中要求不含重复的数字。 return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 691, 1125 状态压缩问题]]></title>
    <url>%2F2019%2F07%2F16%2F%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[状态压缩在处理字符串问题的时候是一个非常好用的方法，因为在程序中处理字符串的过程是相对来说比较麻烦的，如果将字符串用二进制整型数字来 表示，处理起来就会方便很多，接下来两道题就是比较典型的状态压缩问题。 LeetCode 691 Stickers to Spell Word原题链接 12345678910111213141516171819202122We are given N different types of stickers. Each sticker has a lowercase English word on it.You would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them.You can use each sticker more than once if you want, and you have infinite quantities of each sticker.What is the minimum number of stickers that you need to spell out the target? If the task is impossible, return -1.Example 1:Input:[&quot;with&quot;, &quot;example&quot;, &quot;science&quot;], &quot;thehat&quot;Output:3Explanation:We can use 2 &quot;with&quot; stickers, and 1 &quot;example&quot; sticker.After cutting and rearrange the letters of those stickers, we can form the target &quot;thehat&quot;.Also, this is the minimum number of stickers necessary to form the target string. 题目大意：用数组中的字符串中的一部分字符来组成目标字符串，要求使用的数组中的字符串的次数最少。 这道题一定是用DP来解决，因为不同的状态有可能是由多个子问题来构成的，我们需要从中选取一个状态一步一步的往target上去搜索。那么在这个 过程中，需要对字符串进行处理，因为英文字母只有26个，我们用一个长度为26的空数组来存储对应的字符个数。例如&apos;a&apos;，这个字符的位置就是 ord(&apos;a&apos;) - ord(&apos;a&apos;),将字符串转换成数组就好处理多了。并用记忆化来保存递归中的子状态，防止重复递归过程。 123456789101112131415161718192021222324252627282930class Solution: def minStickers(self, stickers: List[str], target: str) -&gt; int: mp = [[0 for _ in range(26)] for _ in range(len(stickers))] for i in range(len(stickers)): for char in stickers[i]: mp[i][ord(char) - ord(&apos;a&apos;)] += 1 dp = &#123;&#125; dp[&quot;&quot;] = 0 def helper(target): if target in dp: return dp[target] if not target: return 0 t = [0] * 26 for char in target: t[ord(char) - ord(&apos;a&apos;)] += 1 res = float(&apos;inf&apos;) for i in range(len(mp)): if mp[i][ord(target[0]) - ord(&apos;a&apos;)] == 0: continue nextt = &quot;&quot; for j in range(26): if t[j] &gt; mp[i][j]: nextt += chr(ord(&apos;a&apos;) + j) * (t[j] - mp[i][j]) temp = helper(nextt) if temp != -1: res = min(res, temp + 1) dp[target] = -1 if res == float(&apos;inf&apos;) else res return dp[target] return helper(target) 其实这道题还不算是非常典型的状态压缩，只不过转换过了一种形式来保存字符串，我曾经尝试过另一种方法，不过这种方法在Python3中有个别case 没有通过，不过肯定是一套正确的代码。 1234567891011121314151617181920class Solution: def minStickers(self, stickers: List[str], target: str) -&gt; int: _len = 1 &lt;&lt; len(target) dp = [float(&apos;inf&apos;) for _ in range(_len)] dp[0] = 0 for i in range(len(dp)): if dp[i] == float(&apos;inf&apos;): continue for s in stickers: index = self.findnextstatus(i, target, s) dp[index] = min(dp[index], dp[i] + 1) return dp[-1] if dp[-1] != float(&apos;inf&apos;) else -1 def findnextstatus(self, status, target, s): for char in s: for i in range(len(target)): if (status &gt;&gt; i) &amp; 1 == 0 and target[i] == char: status += 1 &lt;&lt; i break return status 上面这种方法有点接近暴力搜索，比如target是&apos;thehat&apos;，我们可以将其转换成111111，每一位1代表当前位置的字符是否扫描过，可以用整型数字 来表示，搜索的时候我们直接用与运算就可以找出两个字符串重叠的部分，用dp数组来保存每一个位置的状态，每一个位置的index值都是整型的，转 换成2进制，每一个位置的1代表当前位置的字符还没被搜索过。 LeetCode 1125 Smallest Sufficient Team原题链接 123456789101112131415161718192021In a project, you have a list of required skills req_skills, and a list of people. The i-th person people[i] contains a list of skills that person has.Consider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill. We can represent these teams by the index of each person: for example, team = [0, 1, 3] represents the people with skills people[0], people[1], and people[3].Return any sufficient team of the smallest possible size, represented by the index of each person.You may return the answer in any order. It is guaranteed an answer exists. Example 1:Input: req_skills = [&quot;java&quot;,&quot;nodejs&quot;,&quot;reactjs&quot;], people = [[&quot;java&quot;],[&quot;nodejs&quot;],[&quot;nodejs&quot;,&quot;reactjs&quot;]]Output: [0,2]Example 2:Input: req_skills = [&quot;algorithms&quot;,&quot;math&quot;,&quot;java&quot;,&quot;reactjs&quot;,&quot;csharp&quot;,&quot;aws&quot;], people = [[&quot;algorithms&quot;,&quot;math&quot;,&quot;java&quot;],[&quot;algorithms&quot;,&quot;math&quot;,&quot;reactjs&quot;],[&quot;java&quot;,&quot;csharp&quot;,&quot;aws&quot;],[&quot;reactjs&quot;,&quot;csharp&quot;],[&quot;csharp&quot;,&quot;math&quot;],[&quot;aws&quot;,&quot;java&quot;]]Output: [1,2] 题目大意：在招聘的过程中，我们需要组成一个team，这个team中必须要有req_skills中的所有技术。我们需要招最少的人，但是还要满足所有的 需求。 这是一道周赛题，我只记得那周周赛前面做的比较懵，做到这道题的时候看了看就到时间了。后来仔细看了下这道题，感觉这道题蕴含了很多很多的东 西，首先这是一个背包类DP问题，还是一个搜索加上状态压缩的问题。因为这个问题的时间复杂度，最高可以达到O(2 ** n),这个n是指req_skills 的长度，当然people中没有这么多组合。但是处理这么高复杂度的问题，在处理字符串会非常的麻烦，所以我们可以用二进制整型数字来表示其状态。 例如例子中用二进制数字来表示为111，每一位置上的1代表一种技术，具体是第几位的，由req_skills中的顺序决定，并存入字典中，方便搜索的时候， 排除不需要的技能。搜索的时候比如一个人的技能是&apos;nodejs&apos;,&apos;reactjs&apos;，那么当前状态就是101，那么比如另一个人会&apos;java&apos;那么这个人的状态就是 010，那么这两个人能凑成什么样的状态呢，我们不用具体去搜索，直接将两个二进制整型数字进行或运算5 | 2，等于7，转换成2进制就是111，说明 这个组合满足要求，具体是不是最优解，我们需要存入DP中，如果由不同子状态打成目标状态，如果人数更少，我们需要重新更新dp，用一个字典来表示， 字典中对应的value是哪些人构成当前状态的数组，方便调取结果。 参考链接 12345678910111213141516171819class Solution: def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -&gt; List[int]: dic = collections.defaultdict(int) for i, r in enumerate(req_skills): dic[r] = i dp = &#123;0: []&#125; for i, p in enumerate(people): tempdp = dp intskill = 0 for skill in p: if skill in dic: intskill |= 1 &lt;&lt; dic[skill] for ints, need in list(dp.items()): total = ints | intskill if total == ints: continue if total not in dp or len(dp[total]) &gt; len(need) + 1: dp[total] = need + [i] return dp[(1 &lt;&lt; len(req_skills)) - 1] 虽然是一道很难的题，一开始做真的很头痛没啥思路，但是感觉这题比较有意义。]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 140, 472 字符串分割问题]]></title>
    <url>%2F2019%2F07%2F14%2Fwordbreak%2F</url>
    <content type="text"><![CDATA[LeetCode 140 Word Break II原题链接 12345678910111213141516171819202122232425262728293031Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.Note:The same word in the dictionary may be reused multiple times in the segmentation.You may assume the dictionary does not contain duplicate words.Example 1:Input:s = &quot;catsanddog&quot;wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]Output:[ &quot;cats and dog&quot;, &quot;cat sand dog&quot;]Example 2:Input:s = &quot;pineapplepenapple&quot;wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]Output:[ &quot;pine apple pen apple&quot;, &quot;pineapple pen apple&quot;, &quot;pine applepen apple&quot;]Explanation: Note that you are allowed to reuse a dictionary word. 题目大意：给定一个字符串，用数组中存在的字符串来分割原有字符串。 这种问题其实是一个比较典型的DFS（深度优先搜索）问题，通过扫描字符串，然后看扫描的前缀位置的字符串是否存在在wordDict中，然后通过递归 继续搜索，到最深位置，退栈，找到一个子结果，存入到结果中，然后继续进行其他递归的子问题。 为了提高效率，防止重复的递归过程，使用记忆化的方法来存储已经搜索过的字符串，如果在接下来的递归过程中出现相同的字符串，可以直接从字典 中提取出结果。 123456789101112131415161718class Solution: def wordBreak(self, s: str, wordDict: List[str]) -&gt; List[str]: self.dic = &#123;&#125; wordDict = set(wordDict) return self.dfs(s, wordDict) def dfs(self, s, wordDict): if not s: return [&apos;&apos;] res = [] for word in wordDict: if s in self.dic: return self.dic[s] if s[:len(word)] != word: continue for sub in self.dfs(s[len(word):], wordDict): res.append(word if not sub else word + &quot; &quot; + sub) self.dic[s] = res return res 刚开始做这道题的时候，没有用memoization，然后发现有个案例一直通不过去，一直在无限递归。中间有一个字符b，然后字典中根本不存在b这个字 符，导致一直卡在这里,因为在递归过程中，系统在无限处理已经处理过的子问题，所以我们需要将处理过的子问题保存下来。 123&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;[&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;,&quot;aaaaa&quot;,&quot;aaaaaa&quot;,&quot;aaaaaaa&quot;,&quot;aaaaaaaa&quot;,&quot;aaaaaaaaa&quot;,&quot;aaaaaaaaaa&quot;] LeetCode 472 Concatenated Words原题链接 12345678910111213141516Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words.A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.Example:Input: [&quot;cat&quot;,&quot;cats&quot;,&quot;catsdogcats&quot;,&quot;dog&quot;,&quot;dogcatsdog&quot;,&quot;hippopotamuses&quot;,&quot;rat&quot;,&quot;ratcatdogcat&quot;]Output: [&quot;catsdogcats&quot;,&quot;dogcatsdog&quot;,&quot;ratcatdogcat&quot;]Explanation: &quot;catsdogcats&quot; can be concatenated by &quot;cats&quot;, &quot;dog&quot; and &quot;cats&quot;; &quot;dogcatsdog&quot; can be concatenated by &quot;dog&quot;, &quot;cats&quot; and &quot;dog&quot;; &quot;ratcatdogcat&quot; can be concatenated by &quot;rat&quot;, &quot;cat&quot;, &quot;dog&quot; and &quot;cat&quot;.Note:The number of elements of the given array will not exceed 10,000The length sum of elements in the given array will not exceed 600,000.All the input string will only include lower case letters.The returned elements order does not matter. 题目大意：找出所有数组中的字符串，要求字符串必须至少分成2份，并且每一份子字符串都在数组中。其实这道题目和上一道题差不多，也是对字符 串进行分割的问题，我们只需要进行递归搜索，并判断分割的每一部分是否在数组中，如果存在其中一种分割方法满足要求，说明这个字符串满足要求， 同时用字典保存已经处理过的字符串，防止后面的递归中有重复的操作。 1234567891011121314151617181920212223242526class Solution: def findAllConcatenatedWordsInADict(self, words: List[str]) -&gt; List[str]: words = set(words) memo = &#123;&#125; def dfs(word): if word in memo: return memo[word] memo[word] = False for i in range(1, len(word)): pre = word[:i] suf = word[i:] if pre in words and suf in words: memo[word] = True break if pre in words and dfs(suf): memo[word] = True break if suf in words and dfs(pre): memo[word] = True break return memo[word] res = [] for word in words: if dfs(word): res.append(word) return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Biweekly Contest 4 总结]]></title>
    <url>%2F2019%2F07%2F13%2Fbiweekly4%2F</url>
    <content type="text"><![CDATA[LeetCode 1118 Number of Days in a Month123456789101112131415161718192021222324Given a year Y and a month M, return how many days there are in that month. Example 1:Input: Y = 1992, M = 7Output: 31Example 2:Input: Y = 2000, M = 2Output: 29Example 3:Input: Y = 1900, M = 2Output: 28 Note:1583 &lt;= Y &lt;= 21001 &lt;= M &lt;= 12 日常签到题，分别判断是不是闰年，然后判断月份，返回当前月中有多少天。 12345678910111213class Solution: def numberOfDays(self, Y: int, M: int) -&gt; int: if M in [1, 3, 5, 7, 8, 10, 12]: return 31 elif M in [4, 6, 9, 11]: return 30 elif M == 2: if Y % 400 == 0: return 29 elif Y % 4 == 0 and Y % 100 != 0: return 29 else: return 28 LeetCode 1119 Remove Vowels from a String12345678910111213141516171819Given a string S, remove the vowels &apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, and &apos;u&apos; from it, and return the new string. Example 1:Input: &quot;leetcodeisacommunityforcoders&quot;Output: &quot;ltcdscmmntyfrcdrs&quot;Example 2:Input: &quot;aeiou&quot;Output: &quot;&quot; Note:S consists of lowercase English letters only.1 &lt;= S.length &lt;= 1000 也是个签到题，扫描字符串，如果是元音字符就忽略，不是的保存下来，返回新的字符串。 1234567class Solution: def removeVowels(self, S: str) -&gt; str: res = &quot;&quot; for char in S: if char not in [&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;]: res += char return res LeetCode 1120 Maximum Average Subtree12345678910111213141516Given the root of a binary tree, find the maximum average value of any subtree of that tree.(A subtree of a tree is any node of that tree plus all its descendants. The average value of a tree is the sum of its values, divided by the number of nodes.) Example 1:Input: [5,6,1]Output: 6.00000Explanation: For the node with value = 5 we have and average of (5 + 6 + 1) / 3 = 4.For the node with value = 6 we have and average of 6 / 1 = 6.For the node with value = 1 we have and average of 1 / 1 = 1.So the answer is 6 which is the maximum. 题目大意：求一个二叉树中，最大平均值的子树。递归扫描二叉树，每到一个节点判断一次数值大小即可。 1234567891011121314151617181920# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def maximumAverageSubtree(self, root: TreeNode) -&gt; float: self.res = 0 def helper(node, count): if not node: return 0, 0 else: l = helper(node.left, count) r = helper(node.right, count) self.res = max(self.res, (l[0] + r[0] + node.val) / (1 + l[1] + r[1])) return l[0] + r[0] + node.val, 1 + l[1] + r[1] helper(root, 0) return float(&apos;%.5f&apos;%self.res) LeetCode 1121 Divide Array Into Increasing Sequences123456789101112131415161718192021222324Given a non-decreasing array of positive integers nums and an integer K, find out if this array can be divided into one or more disjoint increasing subsequences of length at least K. Example 1:Input: nums = [1,2,2,3,3,4,4], K = 3Output: trueExplanation: The array can be divided into the two subsequences [1,2,3,4] and [2,3,4] with lengths at least 3 each.Example 2:Input: nums = [5,6,6,7,8], K = 3Output: falseExplanation: There is no way to divide the array using the conditions required. Note:1 &lt;= nums.length &lt;= 10^51 &lt;= K &lt;= nums.length1 &lt;= nums[i] &lt;= 10^5 题目大意：一个有序递增的数组，判断这个数组是否可以分组，要求每一组至少有K个元素，而且每一组都要求有序递增的。我一看是个hard题目，还 想着用DP来做- -但是感觉有点复杂。考虑了一会儿发现其实这个问题，我们只需要得出最多可以分多少个组，然后原数组中的元素出现最多的次数是否 小于等于分组的数目即可。有点脑筋急转弯的意思。 123class Solution: def canDivideIntoSubsequences(self, nums: List[int], K: int) -&gt; bool: return max(collections.Counter(nums).values()) &lt;= len(nums) // K]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 315, 493 Binary Indexed Tree]]></title>
    <url>%2F2019%2F07%2F12%2Fbit%2F</url>
    <content type="text"><![CDATA[这篇主要想记录一下BIT系列的问题（Binary Indexed Tree),这个是一个比较巧妙的数据结构，虽然不是很常见，但是针对一些特殊问题，有着非 常好的效果，如果单纯的凭借文字叙述可能不太好描述这个数据结构，推荐下列一个视频。 视频链接 如果想更清楚的了解整个BIT的运算过程，可以去尝试下面这个网站，可以自己亲手操作。 网页链接 LeetCode 315 Count of Smaller Numbers After Self原题链接 123456789101112You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].Example:Input: [5,2,6,1]Output: [2,1,1,0] Explanation:To the right of 5 there are 2 smaller elements (2 and 1).To the right of 2 there is only 1 smaller element (1).To the right of 6 there is 1 smaller element (1).To the right of 1 there is 0 smaller element. 题目大意：给出一个数组，里面的元素全是数字，要求返回一个数组。需要求出每一个元素右边有多少个元素比当前的元素小。 Brute Force的方法可能比较直接，分别针对每一个元素扫描其右边的所有元素，得出结果。但是这样的做法是非常不效率的，因为每一次扫描的过程 中，都包含着非常多重复的过程，时间复杂度大约是N的阶乘，显然如果数据规模非常大，这样的做法是不可取的。如果用BIT来解决这个问题，时间 复杂度为nlogn。简单说一下过程，首先将数组排序，用一个rank字典来存储数组中每一个元素，每个元素对应的是这个元素在数组中的大小位置，方 便后面BIT的操作。然后逆序扫描整个数组，用扫描到当前元素的rank来查找BIT，求出当前BIT中有多少比这个元素的rank大的元素。然后把当前扫 描的元素更新到BIT中。具体BIT的运作原理，建议认真去看一下上述的链接，我认为是讲解BIT最好的视频！ 123456789101112131415161718192021class Solution: def countSmaller(self, nums: List[int]) -&gt; List[int]: rank = &#123;&#125; for i, num in enumerate(sorted(nums)): rank[num] = i + 1 bit = [0] * (len(nums) + 1) def update(i): while i &lt; len(bit): bit[i] += 1 i += (i &amp; -i) def query(i): res = 0 while i: res += bit[i] i -= (i &amp; -i) return res res = [] for num in reversed(nums): res.append(query(rank[num] - 1)) update(rank[num]) return res[::-1] LeetCode 493 Reverse Pairs原题链接 123456789101112131415Given an array nums, we call (i, j) an important reverse pair if i &lt; j and nums[i] &gt; 2*nums[j].You need to return the number of important reverse pairs in the given array.Example1:Input: [1,3,2,3,1]Output: 2Example2:Input: [2,4,3,5,1]Output: 3Note:The length of the given array will not exceed 50,000.All the numbers in the input array are in the range of 32-bit integer. 题目大意：虽然这个题目叫reverse pairs，但是本质上和上面的题类似，唯一的变化就是在小的基础上，左边的数字要比右边的数字的2倍要大， 而且如果是负数，操作起来会有点复杂。但是大致上的操作过程和上一题是一样的。 首先需要对数组进行预处理，将原数组中所有元素的值乘以2加入到数组中，然后针对现在所有的元素进行分级，和上题一样存入rank中，方便后续 BIT的操作，针对bit查询的时候，我们根据当前扫描的元素的rank - 1的位置来查询，更新的时候我们在这个数字乘以2的rank位置进行更新，这样 做的目的主要是为了处理负数。 123456789101112131415161718192021222324class Solution: def reversePairs(self, nums: List[int]) -&gt; int: if not nums: return 0 def update(i): while i &lt; len(bit): bit[i] += 1 i += (i &amp; -i) def query(i): res = 0 while i: res += bit[i] i -= (i &amp; -i) return res rank = &#123;&#125; newnum = nums + [x * 2 for x in nums] for i, n in enumerate(sorted(list(set(newnum)))): rank[n] = i + 1 bit = [0] * (len(set(newnum)) + 1) res = 0 for n in nums[::-1]: res += query(rank[n] - 1) update(rank[n * 2]) return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Binary Indexed Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 407,417 BFS(广度优先搜索)类问题]]></title>
    <url>%2F2019%2F07%2F09%2F407-417%2F</url>
    <content type="text"><![CDATA[LeetCode 407 Trapping Rain Water II原题链接 123456789101112131415161718192021Given an m x n matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining. Note:Both m and n are less than 110. The height of each unit cell is greater than 0 and is less than 20,000. Example:Given the following 3x6 height map:[ [1,4,3,1,3,2], [3,2,1,3,2,4], [2,3,3,2,3,1]]Return 4. 题目大意：这道题其实和Trapping Rain Water II很像，只不过现在的问题题比之前的问题高了一个维度，还是求这个物体总共能接收多少雨。 在前面的问题中我们是用双指针的方法来解决的，这道题其实也可以用双指针的方法来解决，不过这个双指针怎么来运作比较难想。换一个角度，一个 立体的模型，如果希望他能接住物体，那么一定在内部的某一些位置存在一些凹形的模型，那么我们只要找到这个凹形就可以了。那么怎么来进行操作， 这里就涉及到一个算法叫做BFS（广度优先搜索）。我们要找到内部存在的凹形模型，我们就需要从整个模型的最外层入手，一点一点的往内部搜索，来 判断是否存在这个凹形就可以了。我们用一个栈来维护最外层的所有点，然后每一次pop出一个最低的点，因为能盛多少水，取决于周围最低的那个板。 这里找最小值，可以使用堆排序来完成，来优化搜索。然后找到新的点，并且这个点没有被扫描过，将其入堆，然后进行下一轮的搜索，直到扫描完所 有的位置。 12345678910111213141516171819202122class Solution: def trapRainWater(self, heightMap: List[List[int]]) -&gt; int: if not heightMap or not heightMap[0]: return 0 heap = [] seen = set() for i in range(len(heightMap)): #这个双循环是为了将整个模型的最边上的所有点扫描入堆。 for j in range(len(heightMap[0])): if i == 0 or j == 0 or i == len(heightMap) - 1 or j == len(heightMap[0]) - 1: heapq.heappush(heap, (heightMap[i][j], i, j)) seen.add((i, j)) res = 0 directions = [[1, 0], [-1, 0], [0, 1], [0, -1]] while heap: #BFS部分 height, i, j = heapq.heappop(heap) for d in directions: newi, newj = i + d[0], j + d[1] if 0 &lt;= newi &lt; len(heightMap) and 0 &lt;= newj &lt; len(heightMap[0]) and (newi, newj) not in seen: res += max(0, height - heightMap[newi][newj]) heapq.heappush(heap, (max(height, heightMap[newi][newj]), newi, newj)) # 新入堆的位置的高度，一定是两个点比较后的最高位置。 seen.add((newi, newj)) return res LeetCode 417 Pacific Atlantic Water Flow原题链接 12345678910111213141516171819202122232425262728Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the &quot;Pacific ocean&quot; touches the left and top edges of the matrix and the &quot;Atlantic ocean&quot; touches the right and bottom edges.Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.Note:The order of returned grid coordinates does not matter.Both m and n are less than 150. Example:Given the following 5x5 matrix: Pacific ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) * ~ 3 2 3 (4) (4) * ~ 2 4 (5) 3 1 * ~ (6) (7) 1 4 5 * ~ (5) 1 1 2 4 * * * * * * AtlanticReturn:[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix). 这道题目和407其实很像，407是找中间的最低位置，这道题是找中间的最高位置。简单描述下题目，一个矩阵，矩阵中的每个点的值都代表是当前位置 的海拔高度，左上角是太平洋，右下角是大西洋，要求我们找到所有点，其中每个点的谁可以流向两个海洋。这道题的做法和407几乎一样，从边上往 中心进行BFS，最后找到两个BFS结果的并集就可以了。 12345678910111213141516171819202122232425class Solution: def pacificAtlantic(self, matrix: List[List[int]]) -&gt; List[List[int]]: if not matrix: return [] p = set() a = set() for i in range(len(matrix[0])): p.add((0, i)) a.add((len(matrix) - 1, i)) for i in range(len(matrix)): p.add((i, 0)) a.add((i, len(matrix[0]) - 1)) def bfs(seen): queue = collections.deque(seen) directions = [[1, 0], [-1, 0], [0, 1], [0, -1]] while queue: i, j = queue.popleft() for d in directions: newi, newj = i + d[0], j + d[1] if 0 &lt;= newi &lt; len(matrix) and 0 &lt;= newj &lt; len(matrix[0]) and (newi, newj) not in seen and matrix[newi][newj] &gt;= matrix[i][j]: queue.append((newi, newj)) seen.add((newi, newj)) return seen return list(bfs(p) &amp; bfs(a)) 需要分别对两个海洋进行BFS，因为每次的起点不同，找到两个海洋中的最高位置，看看这些最高位置有没有重合的部分，这些部分就是我们需要找的点。]]></content>
      <categories>
        <category>高频</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 84，85，42 最大矩形系列问题]]></title>
    <url>%2F2019%2F07%2F08%2FLargestRectangle%2F</url>
    <content type="text"><![CDATA[今天总结几道用栈来解决最大面积问题，也算是高频题，面试中经常出现。 LeetCode 84 Largest Rectangle in Histogram原题链接 题目大意：通过扫描矩阵，找出由几个不同的矩形所构成的矩形面积的最大值。 如果由几个不同的矩形构成一个矩形，假设他们在同一水平线，那么这个矩形的高度应该由最低的那个矩形决定，然后构成的这个矩形是否是面积最大， 这还不一定，需要继续扫描其他的矩形来判断，其实这就是这个栈的思想，这道题里面用的是递增栈。我们用一个栈来维护扫描过的矩形，如果当前扫描 的这个矩形高于栈尾的矩形，那么不进行任何操作，直接入栈。如果当前的矩形小于那么我们需要进行退栈，pop出一个矩形，那么这个矩形的宽度， 应该是从当前扫描的位置，到现在栈尾的位置，一直扫描到数组结束即可。虽然是一道hard的题，但是比较好想，通过代码来分析。 123456789101112class Solution: def largestRectangleArea(self, heights: List[int]) -&gt; int: stack = [] res = 0 #维护这个最大值 heights.append(0) for i, h in enumerate(heights): while stack and h &lt; heights[stack[-1]]: #持续退栈来找出当前比较高的矩形，来寻找当前这个高度的矩形最大面积。 index = stack.pop() w = i if not stack else i - stack[-1] - 1 res = max(res, heights[index] * w) stack.append(i) return res LeetCode 85 Maximal Rectangle原题链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445Given a 2D binary matrix filled with 0&apos;s and 1&apos;s, find the largest rectangle containing only 1&apos;s and return its area.Example:Input:[ [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]Output: 6``` 这道题目相比上一道题目稍微难想，因为上一个题，每一个相同的index位置的矩形都是连续的，然而这道题是以一个2D矩阵来表示的，这其中同一个 位置的矩形中间可能是断开的，所以单纯的使用上一道题的方法是行不通的。我们可以通过一层一层的扫描这个矩阵，来确保每一个位置的矩形都是连 续的，然后针对当前的层数进行扫描得出结果，这就很巧妙的转换成上一题的做法。 ```angular2class Solution: def maximalRectangle(self, matrix: List[List[str]]) -&gt; int: if not matrix or not matrix[0]: return 0 res = 0 height = [0] * len(matrix[0]) for i in range(len(matrix)): #一层一层的扫描将数据传入height中 for j in range(len(matrix[0])): if matrix[i][j] == &apos;1&apos;: #如果矩阵当前位置等于1，那么说明到这个位置和上一层的矩形是相连接的，所以高度需要加1. height[j] += 1 else: #如果矩阵当前位置等于0，说明到这一层这个位置的矩形断开了，我们需要将height中这个位置归0. height[j] = 0 res = max(res, self.check(height)) #每一层扫描结束，我们需要对到这一层为止的height，进行和上一题同样的递增栈处理。 return res def check(self, height): #辅助函数，功能和上一题一样。 height = height + [0] stack = [] res = 0 for i, h in enumerate(height): while stack and h &lt; height[stack[-1]]: index = stack.pop() w = i if not stack else i - stack[-1] - 1 res = max(res, height[index] * w) stack.append(i) return res LeetCode 42 Trapping Rain Water原题链接 1234567891011Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!Example:Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 这道题是一道高频题，各大公司都有用过这道题目，大概意思就是图中不同位置有不同高度的矩形，会存在高低不同导致一些坑的形成，当下雨时，这 个系统能接住多少雨水。这道题目看上去有些复杂，实际是就是把之前的问题反过来想。只有形成凹的形状时才能保存雨水，所以我们这里需要运用递 减栈，通过扫描整个数组来维护这个递减栈，如果发现栈尾的矩形高度比当前低，说明形成洼地了，可以接住雨水，这时候计算出高度差和高度即可。 这个过程其实类似于一层一层的存水。 123456789101112131415class Solution: def trap(self, height: List[int]) -&gt; int: stack = [] res = 0 for i, h in enumerate(height): while stack and h &gt; height[stack[-1]]: #当前的高度大于栈尾的高度，那么说明栈尾的矩形是当前这一块位置的最低点。 index = stack.pop() if not stack: break hei = min(h, height[stack[-1]]) width = i - stack[-1] - 1 #将矩形pop出来后，当前栈尾的位置到当前扫描的位置是宽度。 res += (hei - height[index]) * width # 需要计算出pop出的矩形两边的高度，哪一边矮，那么这就是高度。 stack.append(i) return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>FaceBook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 753 Cracking the Safe]]></title>
    <url>%2F2019%2F07%2F07%2F753crackingthesafe%2F</url>
    <content type="text"><![CDATA[LeetCode 753 Cracking the Safe原题链接1234567891011121314151617181920212223There is a box protected by a password. The password is a sequence of n digits where each digit can be one of the first k digits 0, 1, ..., k-1.While entering a password, the last n digits entered will automatically be matched against the correct password.For example, assuming the correct password is &quot;345&quot;, if you type &quot;012345&quot;, the box will open because the correct password matches the suffix of the entered password.Return any password of minimum length that is guaranteed to open the box at some point of entering it. Example 1:Input: n = 1, k = 2Output: &quot;01&quot;Note: &quot;10&quot; will be accepted too.Example 2:Input: n = 2, k = 2Output: &quot;00110&quot;Note: &quot;01100&quot;, &quot;10011&quot;, &quot;11001&quot; will be accepted too. 题目大意：类似一个破解密码的系统，这个系统很有意思，我们可以一直输入一串密码，如果在输入过程中有一部分和指定密码完全重合，那么这个 密码就被破解了。要求我们构造一个最短的字符串，里面需要包含所有可能的密码。 其实这个早就被前人证明过了，叫做De Bruijin sequence问题，反正具体怎么证明的我是智商有限，有兴趣的可以去wiki上去看一下，我先上一份 LeetCode disscusion 区的一份代码，非常的简洁，先来分析一下。 1234567891011121314151617class Solution(object): def crackSafe(self, n, k): &quot;&quot;&quot; :type n: int :type k: int :rtype: str &quot;&quot;&quot; ans = &quot;0&quot; * (n - 1) visits = set() for x in range(k ** n): current = ans[-n+1:] if n &gt; 1 else &apos;&apos; for y in range(k - 1, -1, -1): if current + str(y) not in visits: visits.add(current + str(y)) ans += str(y) break return ans 源码链接 简单分析一下这个代码，首先初始化一个答案的前缀(&apos;0&apos; * (n - 1)),通过循环每一次往前缀后面添加一个数字，如果这个数字和前缀组成的一个新 的密码，我们没有处理过（不在visits）中，那么我们更新当前的总字符串，然后持续更新。需要循环k ** n次，这个次数是所有的密码总数。最后 返回答案即可。 当时看到这个代码的时候我没有进行特别深刻的分析，但是看到网上有网友说，他在Google onsite的时候问到这么一个问题，他当时写这个代码的 时候虽然是完全可以通过的，但是被面试官问了好多关于证明的问题。然后我回过头来仔细分析了一下这个代码，里面确实存在很多不确定或者无法分 析的地方，但是在LeetCode中这个代码完全可以通过。 第一点，为什么循环k ** n次一定能找到这个答案。第二点是我自己写的时候发现的问题，为什么在current后面添加新的元素的时候，一定要倒序 遍历k范围内的值，我自己写的时候是正序遍历，但是答案是错的。我在网上搜索了很多关于这个答案的做法，大部分的文章，大部分感觉都特别敷衍， 代码和上述代码类似，但是完全解释不清楚。其实面试的时候写出这种代码被问住了会特别特别尴尬。 花花的讲解 这个讲解分析的就特别清楚，如果有兴趣可以参考。 我自己写了一个代码，看上去接近Brute Force，但是却通过了所有的Test case。先看代码。 1234567891011121314151617181920212223class Solution: def crackSafe(self, n: int, k: int) -&gt; str: self.total = k ** n self.res = &apos;0&apos; * n self.seen = set() self.seen.add(self.res) self.dfs(n, k) return self.res def dfs(self, n, k): if len(self.seen) == self.total: return True cur = self.res[len(self.res) - n + 1:] for i in range(k): cur = cur + str(i) if cur not in self.seen: self.seen.add(cur) self.res += str(i) if self.dfs(n, k): return True self.seen.remove(cur) self.res = self.res[:-1] cur = cur[:-1] 这个代码的思路是通过backtrack去进行深度搜索，直到完成搜索时，密码的数量等于总数的时候，在返回总的字符串，其他的时候回溯，继续进行 深度搜索。看上去这样的解法看上去递归深度会非常非常高，实际上这个解法的运行时间只比线性时间慢一点点，这中间省略了很多的回溯过程，这可 能跟De Bruijin sequence的证明有关系，不过没关系这个代码的过程涵盖了所有可能的过程。]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>Hard</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习]]></title>
    <url>%2F2019%2F07%2F05%2Fpython%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Python 语言特性该环节涉及到一些比较细小琐碎的东西，看上去不是很起眼，但是被问到还是很容易出问题。 Python 函数参数传递1234567891011121314example 1:a = 1def fun(a): a = 2fun(a)print(a)example 2:a = []def fun(a): a.append(1)print(a) 首先看第一个例子，我们首先我们给a赋值1，然后通过fun函数来改变a的值，那么运行这个函数之后，a是应该等于1还是等于2？ 第二个例子中，a是一个空的list，通过运行函数，往a中添加1，那么a最后应该变成什么样子？ 在Python中通过传递函数来更改对象a（这个a不是变量，如果是变量那么是可以随意改变的），对象有两种类型，一种是可变对象（mutable）一种 是不可变的对象（immuable）。在Python中不可变对象有：strings，tuple，numbers，可变对象有：list，dict，set。所以第一个例子中a不 会发生任何变化，例子2中的啊变成[1]。 Python methodsPython中有3个方法，静态方法（staticmethon），类方法（classmethod）和实例方法。 123456789def fun(x): print(&quot;Hello World&quot; * x) class A: def fun(self, x): print(&quot;Hello World&quot; * x) def class_fum(cls, x): print(&quot;Hello World&quot; * x)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 329,741]]></title>
    <url>%2F2019%2F07%2F05%2Fcherrypick%2F</url>
    <content type="text"><![CDATA[今天来做一下两道DP的题目，这两道题目都是用记忆化递归来解决，所以就放在一起了。强化DP思想！ LeetCode 329 Longest Increasing Path in a Matrix原题链接 1234567891011121314151617181920212223242526Given an integer matrix, find the length of the longest increasing path.From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).Example 1:Input: nums = [ [9,9,4], [6,6,8], [2,1,1]] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9].Example 2:Input: nums = [ [3,4,5], [3,2,6], [2,2,1]] Output: 4 Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed. 题目大意：在二维矩阵中找到最长递增路径，返回路径长度即可。 这道题明显是一道dp的题目，如果用Brute Force的方法，时间复杂度会非常高，大约是O(2 ** mn),所以说一定是用dp来解决了。 简单说一下思想，比如我们想确定矩阵中某一个点可以构成的最长递增路径，我们需要知道他4个相邻位置的结果，然后判断到当前位置是不是递增的 即可，那么这个过程其实就是一个递归的过程（bottom-up）。但是递归的过程中存在着很多重复的过程，如果不去避免重复的递归，那么其实就和 Brute Force的方法没什么区别了，所以这里需要使用记忆化（memoization）来存储每一个状态的值，当递归时候，处理到已经处理过的部分， 我们直接调用这个状态的值就可以了。可以使用字典来存储各个状态下的值，也方便搜索，因为从字典中找一个key的时间复杂度是线性的。 1234567891011121314151617181920class Solution: def longestIncreasingPath(self, matrix: List[List[int]]) -&gt; int: self.dic = collections.defaultdict(int) self.res = 0 def dfs(i, j, pre): if i &lt; 0 or i &gt;= len(matrix) or j &lt; 0 or j &gt;= len(matrix[0]) or matrix[i][j] &lt;= pre: return 0 if (i, j) in self.dic: return self.dic[(i, j)] path = 1 + max(dfs(i + 1, j, matrix[i][j]), dfs(i - 1, j, matrix[i][j]), dfs(i, j - 1, matrix[i][j]), dfs(i, j + 1, matrix[i][j])) # 当前位置的最长递增路径的值是根据他4个方向的值得到的。 self.res = max(self.res, path) #维护最长路径的值 self.dic[(i, j)] = path #存储当前状态 return path for i in range(len(matrix)): for j in range(len(matrix[0])): dfs(i, j, float(&apos;-inf&apos;)) return self.res 时间复杂度O（mn * mn） 递归的时候一定要注意递归的条件，比如当前位置是不是在矩阵中，已经当前位置的值和之前位置的值的关系（因为我们要找的是递增序列）。 LeetCode 741 Cherry Pickup原题链接 12345678910111213141516171819202122232425262728293031323334353637383940In a N x N grid representing a field of cherries, each cell is one of three possible integers. 0 means the cell is empty, so you can pass through;1 means the cell contains a cherry, that you can pick up and pass through;-1 means the cell contains a thorn that blocks your way. Your task is to collect maximum number of cherries possible by following the rules below: Starting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1);After reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells;When passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0);If there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected. Example 1:Input: grid =[[0, 1, -1], [1, 0, -1], [1, 1, 1]]Output: 5Explanation: The player started at (0, 0) and went down, down, right right to reach (2, 2).4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].Then, the player went left, up, up, left to return home, picking up one more cherry.The total number of cherries picked up is 5, and this is the maximum possible. Note:grid is an N by N 2D array, with 1 &lt;= N &lt;= 50.Each grid[i][j] is an integer in the set &#123;-1, 0, 1&#125;.It is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1. 题目大意：二维矩阵中有3个状态，0代表可以通过，1代表该位置有樱桃可以通过，-1代表是个障碍无法通过。两个人同时从起点走向终点，问最多 总共得到多少樱桃。 这个题其实和上面的题的思想是一样的，都是找最大值路径的问题，只不过这个问题有两个人同时在走，所以需要我们同时维护两条路径，并且每一条 路径的前进方式可能不一样（下下，下右，右下，右右），不同的前进方式的收益是不一样的，我们需要找到最大的。两条路径和一条路径看上去复杂 一些，实际上没有任何区别，我们用一个状态同时存储两个点就是了。每一个状态都是跟之前的状态有关系，所以一样使用记忆化存储状态，然后碰见 处理过的状态直接调用就可以。直接看代码。 12345678910111213141516171819202122232425262728293031class Solution: def cherryPickup(self, grid: List[List[int]]) -&gt; int: dic = collections.defaultdict(int) #状态存储 if grid[-1][-1] == -1: #如果走不到终点，直接返回-1 return -1 def dp(i1, j1, i2, j2): if (i1, j1, i2, j2) in dic: #如果处理过这个状态，直接从字典中调取即可 return dic[(i1, j1, i2, j2)] if i1 == len(grid) or i2 == len(grid) or j1 == len(grid) or j2 == len(grid): return -1 #如果有一个点不在矩阵中，说明这个状态不合法 if i1 == len(grid) - 1 and i2 == len(grid) -1 and j1 == len(grid) - 1 and j2 == len(grid) - 1: return grid[-1][-1] # 递归的最深位置，我们需要获得这个位置的值 if grid[i1][j1] == -1 or grid[i2][j2] == -1: #碰到障碍，说明这条路不通，也返回-1 return -1 dd = dp(i1 + 1, j1, i2 + 1, j2) rr = dp(i1, j1 + 1, i2, j2 + 1) dr = dp(i1 + 1, j1, i2, j2 + 1) rd = dp(i1, j1 + 1, i2 + 1, j2) #上面的4个值，带表2条路径的前进模式 maxoutput = max(dd, rr, dr, rd) # 需要从不同的前进模式中找到最大收益 if maxoutput == -1: output = -1 else: #如果两条路径路过同一个点，我们只能摘1次樱桃！****** if i1 == i2 and j1 == j2: output = maxoutput + grid[i1][j1] else: output = maxoutput + grid[i1][j1] + grid[i2][j2] dic[(i1, j1, i2, j2)] = output #存储状态 return output return dp(0, 0, 0, 0) if dp(0, 0, 0, 0) &gt; 0 else 0]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 317,296 Shortest Distance from All Buildings]]></title>
    <url>%2F2019%2F07%2F02%2F317%2F</url>
    <content type="text"><![CDATA[LeetCode 296 Best Meeting Point原题链接 123456789101112131415161718A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.Example:Input: 1 - 0 - 0 - 0 - 1| | | | |0 - 0 - 0 - 0 - 0| | | | |0 - 0 - 1 - 0 - 0Output: 6 Explanation: Given three people living at (0,0), (0,4), and (2,2): The point (0,2) is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6. 题目大意：二维矩阵中只存在0和1,0代表是一个空着的位置，1代表一个人，要求在这个矩阵中找到一个位置，使得所有人都走到这个位置的曼哈顿距 离的和最短。 这道题虽然标记成hard题目，其实是一道比较容易的题，至少完全不够hard的难度。他要求的是曼哈顿距离，曼哈顿距离的实质其实就是两点之间的 横坐标的差的绝对值加上纵坐标差的绝对值。那么换个一个方向来思考这个问题，其实就是让我们寻找所有人中间的一个点，所有人到这个点的距离之 和就是最小距离。可能这么说比较难懂，那么我来通过几个比较简单的例子来解释这个问题。 1234567891011121314我们把这个问题简化成1维的数组来看：example1:[1, 6]一个人在位置1，另一个人在位置6，那么总距离为5，没什么好说的example2:[1,2,6]三个人在位置1，2，6，那么所有人都去位置2距离是最短的。为什么这么说呢，因为1和6在这中间任何一个点相遇的总距离都是一样的（6-1），但是2这个点的人如果不用动，就是最佳答案。 答案应该等于（6 - 1） + （2 - 2）example3:[1,2,3,6]在这个例子中，其实无论在位置2相遇或者位置3相遇，都是一样的，所有人都应该往最中心的点靠，用双指针来表示，每一次都应是总距离加上，右边指针的值减去左边指针的值，然后两个指针往中间移一个单位。 那么在二维数组中也是一样的，我们分别将横坐标和纵坐标分开来算就可以了，充分利用曼哈顿距离的性质。代码非常简单，就不多解释了。 12345678910111213141516171819202122class Solution: def minTotalDistance(self, grid: List[List[int]]) -&gt; int: rows = [] cols = [] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: rows.append(i) cols.append(j) cols = sorted(cols) res = 0 l, r = 0, len(rows) - 1 while l &lt; r: res += rows[r] - rows[l] r -= 1 l += 1 l, r = 0, len(cols) - 1 while l &lt; r: res += cols[r] - cols[l] r -= 1 l += 1 return res LeetCode 317 Shortest Distance from All Buildings原题链接 123456789101112131415161718192021222324You want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2, where:Each 0 marks an empty land which you can pass by freely.Each 1 marks a building which you cannot pass through.Each 2 marks an obstacle which you cannot pass through.Example:Input: [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]1 - 0 - 2 - 0 - 1| | | | |0 - 0 - 0 - 0 - 0| | | | |0 - 0 - 1 - 0 - 0Output: 7 Explanation: Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2), the point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.Note:There will be at least one building. If it is not possible to build such house according to the above rules, return -1. 题目其实和上面一题是差不多的，唯一不同的地方就是，二维数组里多了一个数字2,2代表着障碍，意思着不能从这里走。这下就变得比较有意思了， 障碍的出现意味着我们不能找中点来解决这个问题，因为有障碍的存在不能保证每个人到中点的距离都是无障碍的距离。而且障碍还有可能使一些人不 能走到一起，所有情况都要考虑到一起。 那么这时候我们首先需要扫描整个二维数组，知道一共有多少个人。这时候我们对每一个人的位置进行BFS遍历，然后更新每一个新到的位置距离这个 人的距离，同时我们还需要维护一个count(用三维数组来维护这个距离和总数），如果这个count在bfs结束后不等于总人数，那么直接返回-1。针对每一个位置进行BFS后，我们就可以找 到答案。代码还是比较好理解。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def shortestDistance(self, grid: List[List[int]]) -&gt; int: def bfs(i, j, seen): total = 0 queue = collections.deque([(i, j, 0)]) directions = [[1, 0], [-1, 0], [0, 1], [0, -1]] while queue: i, j, dis = queue.popleft() dp[i][j][0] += 1 dp[i][j][1] += dis for d in directions: newi, newj = i + d[0], j + d[1] if newi &lt; 0 or newi &gt;= len(grid) or newj &lt; 0 or newj &gt;= len(grid[0]) or grid[newi][newj] == 2 or (newi, newj) in seen: continue seen.add((newi, newj)) if grid[newi][newj] == 1: total += 1 continue queue.append((newi, newj, dis + 1)) return total dp = [[[0, 0] for _ in range(len(grid[0]))] for _ in range(len(grid))] total = 0 res = float(&apos;inf&apos;) for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: total += 1 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1 and bfs(i, j, set()) != total: return -1 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 0 and dp[i][j][0] == total: res = min(res, dp[i][j][1]) return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Weekly Contest 143]]></title>
    <url>%2F2019%2F06%2F30%2Fcontest143%2F</url>
    <content type="text"><![CDATA[LeetCode Weekly Contest 143LeetCode 1103 Distribute Candies to People题目链接1234567891011121314151617181920212223242526272829303132333435We distribute some number of candies, to a row of n = num_people people in the following way:We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person.Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person.This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end)until we run out of candies. The last person will receive all of our remaining candies (not necessarily one more than the previous gift).Return an array (of length num_people and sum candies) that represents the final distribution of candies. Example 1:Input: candies = 7, num_people = 4Output: [1,2,3,1]Explanation:On the first turn, ans[0] += 1, and the array is [1,0,0,0].On the second turn, ans[1] += 2, and the array is [1,2,0,0].On the third turn, ans[2] += 3, and the array is [1,2,3,0].On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].Example 2:Input: candies = 10, num_people = 3Output: [5,2,3]Explanation: On the first turn, ans[0] += 1, and the array is [1,0,0].On the second turn, ans[1] += 2, and the array is [1,2,0].On the third turn, ans[2] += 3, and the array is [1,2,3].On the fourth turn, ans[0] += 4, and the final array is [5,2,3]. 题目大意：给每个人分配糖果，从1个糖果开始，每一次分配后，加一个糖果，如果每个人都分配完一轮，还有剩余的，那么从头开始继续分配。 不用多解释，签到题。 123456789101112131415class Solution: def distributeCandies(self, candies: int, num_people: int) -&gt; List[int]: res = [0] * num_people start = 1 i = 0 while start &lt;= candies: res[i] += start candies -= start start += 1 i += 1 if i == len(res): i = 0 if candies: res[i] += candies return res LeetCode 1104 Path In Zigzag Labelled Binary Tree题目链接 123456789101112131415161718In an infinite binary tree where every node has two children, the nodes are labelled in row order.In the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.Given the label of a node in this tree, return the labels in the path from the root of the tree to the node with that label. Example 1:Input: label = 14Output: [1,3,4,14]Example 2:Input: label = 26Output: [1,2,6,10,26] 题目大意：从一个二叉树中找到一个路径，路径的终点是label。需要注意的是这个二叉树按照层序遍历，一行是正序，下一行是逆序的，直到结束。 这道题做的时候出现了重大的失误，感觉没有什么头绪，用了个Brute Force的方法构建一个二叉树，然后用DFS来找这个路径。真的是非常愚蠢了。 结果是超时的，耽误了很多时间。其实这道理有个规律,找到这个规律其实非常简单，当时脑子也是秀逗了。比如在第i层，那么这一层的所有数字都 应该在（2 ** i）到（2 ** （i + 1))这个区间里，我们从下到上来搜索，那么上一层的数字应该是下一层的数字除以2，并且取证，但是由于每一 层之间的顺序是不同的，所以我们只需要找到这个点的对称点即可，重复这些步骤，直到顶层，返回的时候，逆序结果输出就是答案了。 123456789101112131415161718class Solution: def pathInZigZagTree(self, label: int) -&gt; List[int]: level = -1 total = 0 while total &lt; label: level += 1 total += 2 ** level res = [label] level -= 1 cur = label // 2 while level &gt; -1: start, end = 2 ** level, (2 ** (level + 1)) - 1 cur = start + end - cur res.append(cur) cur = cur // 2 level -= 1 return res[::-1] LeetCode 1106 Parsing A Boolean Expression题目链接 123456789101112131415161718192021222324252627282930313233343536Return the result of evaluating a given boolean expression, represented as a string.An expression can either be:&quot;t&quot;, evaluating to True;&quot;f&quot;, evaluating to False;&quot;!(expr)&quot;, evaluating to the logical NOT of the inner expression expr;&quot;&amp;(expr1,expr2,...)&quot;, evaluating to the logical AND of 2 or more inner expressions expr1, expr2, ...;&quot;|(expr1,expr2,...)&quot;, evaluating to the logical OR of 2 or more inner expressions expr1, expr2, ... Example 1:Input: expression = &quot;!(f)&quot;Output: trueExample 2:Input: expression = &quot;|(f,t)&quot;Output: trueExample 3:Input: expression = &quot;&amp;(t,f)&quot;Output: falseExample 4:Input: expression = &quot;|(&amp;(t,f,t),!(t))&quot;Output: false Constraints:1 &lt;= expression.length &lt;= 20000expression[i] consists of characters in &#123;&apos;(&apos;, &apos;)&apos;, &apos;&amp;&apos;, &apos;|&apos;, &apos;!&apos;, &apos;t&apos;, &apos;f&apos;, &apos;,&apos;&#125;.expression is a valid expression representing a boolean, as given in the description. 这个题的意思就是就是返回整个字符串最后的结果，其中包含非，或，与，括号的操作。 这个题作为本子周赛标记为最难的题目，其实也不是很难，主要是要找到正确的方法。其实这个题如果没有括号是不是看上去就简单多了，我们直接 实现题目中这几个基本操作就可以了，但是加上了括号，这里面就存在一定的顺序。我的理解和别人不太一样，我是把这个题目看成计算器类型的题目， 因为在计算器类型的题目中，我们用栈来维护一些括号的操作，和这道题里面的情况是一样的，只不过运算符号，变成了逻辑运算符号。 首先我们需要维护当前的操作符号和字符，通过扫描数组把相对应的字符维护起来，当碰到左括号的时候，需要把左括号之前的字符串和操作符号入栈， 然后把操作符和字符串清零，来维护括号里面的元素。关键点在于碰到右括号的时候，我们需要把之前存入栈的操作符号和字符串pop出来，先pop出来 的是操作符，后pop出来的是字符串，用这个pop出来的操作符来操作当前的字符串，然后把结果添加到之前的字符串中，那么这时候相当于我们把这个 括号给去掉了，所以之前的整个字符串变成了当前字符串，继续重复上述操作。实现AND操作就是当数组中有False的时候出False，其他情况出True。 OR操作是有True出True，其他情况出False。（如果记不清楚的可以回去稍微复习下数字电子电路 - -）。 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def parseBoolExpr(self, expression: str) -&gt; bool: stack = [] string = &quot;&quot; op = &quot;&quot; for char in expression: if char in [&apos;!&apos;, &apos;&amp;&apos;, &apos;|&apos;]: op = char elif char in [&apos;t&apos;, &apos;f&apos;]: string += char elif char == &apos;(&apos;: stack.append(string) stack.append(op) string = &quot;&quot; op = &quot;&quot; elif char == &apos;)&apos;: ops = stack.pop() prestring = stack.pop() if ops == &apos;!&apos;: if string == &apos;t&apos;: prestring += &apos;f&apos; elif string == &apos;f&apos;: prestring += &apos;t&apos; elif ops == &apos;&amp;&apos;: if &apos;f&apos; in string: prestring += &apos;f&apos; else: prestring +=&apos;t&apos; elif ops == &apos;|&apos;: if &apos;t&apos; in string: prestring += &apos;t&apos; else: prestring += &apos;f&apos; string = prestring op = &quot;&quot; else: continue return True if string == &apos;t&apos; else False 计算器类似题目LeetCode 227 Basic Calculator IILeetCode 772 Basic Calculator IIILeetCode 224 Basic Calculator LeetCode 1105 Filling Bookcase Shelves题目链接 1234567891011121314151617181920212223242526272829We have a sequence of books: the i-th book has thickness books[i][0] and height books[i][1].We want to place these books in order onto bookcase shelves that have total width shelf_width.We choose some of the books to place on this shelf (such that the sum of their thickness is &lt;= shelf_width), then build another level of shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.Note again that at each step of the above process, the order of the books we place is the same order as the given sequence of books. For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.Return the minimum possible height that the total bookshelf can be after placing shelves in this manner.Example 1:Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4Output: 6Explanation:The sum of the heights of the 3 shelves are 1 + 3 + 2 = 6.Notice that book number 2 does not have to be on the first shelf. Constraints:1 &lt;= books.length &lt;= 10001 &lt;= books[i][0] &lt;= shelf_width &lt;= 10001 &lt;= books[i][1] &lt;= 1000 题目大意：有一个固定大小的抽屉，问怎么摆放才能使整个高度的值最小。 这道题在周赛的时候没有做出来，第二题耽误了太多的时间实在不应该，但是后来仔细做了一下这道题，感觉确实也没什么思路，其实判断出这个题目 是DP的题目并不难，因为如果把所有的书在不同的位置摆放出来，再计算高度，这个时间复杂度会非常非常的高，但是该怎么处理这个DP问题思考了很 久，DP问题一直是我的薄弱环节，经常摸不着头脑，不知道该怎么下手，确实需要一个针对DP的强化训练了。 简单的说一下思路，维护一个dp数组，dp中的每个位置代表到这个位置时最大的高度，通过扫描books，我们需要判断到底是把这本书继续排放在这一 行，还是说把这本书，连带前面几本书，在宽度限制的范围内一起放到下一行，我们需要得到这一个过程中的找到最小值，其实这就是dp中的转移方程。 1234567891011121314151617class Solution: def minHeightShelves(self, books: List[List[int]], shelf_width: int) -&gt; int: dp = [0] for i, b in enumerate(books): j = i w = shelf_width while j &gt;= 0 and w - books[j][0] &gt;= 0: #这个过程就是找出可以移动多少本书到下一行中。 w -= books[j][0] j -= 1 temp = float(&apos;inf&apos;) for k in range(j + 1, i + 1): #这个双循环就是找出这个过程中的最小值，到底连带几本书到下一行的情况是最佳的。 h = 0 for x in range(k, i + 1): h = max(h, books[x][1]) temp = min(temp, dp[k] + h) dp.append(temp) return dp[-1] 这周周赛总结就到这里，感觉在DP方面急需加强，不够DP也是一个比较难学的部分，里面涉及到模型非常多，继续加油！]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Biweekly Contest 3 总结]]></title>
    <url>%2F2019%2F06%2F29%2Fbiweekly3%2F</url>
    <content type="text"><![CDATA[LeetCode Biweekly Contest 3LeetCode 1099 Two Sum Less Than K题目链接 12345678910111213141516171819202122232425Given an array A of integers and integer K, return the maximum S such that there exists i &lt; j with A[i] + A[j] = S and S &lt; K. If no i, j exist satisfying this equation, return -1. Example 1:Input: A = [34,23,1,24,75,33,54,8], K = 60Output: 58Explanation: We can use 34 and 24 to sum 58 which is less than 60.Example 2:Input: A = [10,20,30], K = 15Output: -1Explanation: In this case it&apos;s not possible to get a pair sum less that 15. Note:1 &lt;= A.length &lt;= 1001 &lt;= A[i] &lt;= 10001 &lt;= K &lt;= 2000 题目大意：从数组中找两个数字，他们的和必须小于K，求最大的值。（类似于Amazon某一段时间的OA），比较容易算是一个签到题。 看了一下数据 规模，也没想太多，直接Brute Force就通过了。 12345678class Solution: def twoSumLessThanK(self, A: List[int], K: int) -&gt; int: res = -1 for i in range(len(A) - 1): for j in range(i + 1, len(A)): if A[i] + A[j] &lt; K: res = max(res, A[i] + A[j]) return res 比赛结束，重新思考了一下，其实先将数组排序，然后用双指针来操作，会更快一点。 123456789101112class Solution: def twoSumLessThanK(self, A: List[int], K: int) -&gt; int: A.sort() res = -1 l, r = 0, len(A) - 1 while l &lt; r: if A[l] + A[r] &gt;= K: r -= 1 else: res = max(res, A[l] + A[r]) l += 1 return res LeetCode 1100 Find K-Length Substrings With No Repeated Characters题目链接123456789101112131415161718192021222324Given a string S, return the number of substrings of length K with no repeated characters. Example 1:Input: S = &quot;havefunonleetcode&quot;, K = 5Output: 6Explanation: There are 6 substrings they are : &apos;havef&apos;,&apos;avefu&apos;,&apos;vefun&apos;,&apos;efuno&apos;,&apos;etcod&apos;,&apos;tcode&apos;.Example 2:Input: S = &quot;home&quot;, K = 5Output: 0Explanation: Notice K can be larger than the length of S. In this case is not possible to find any substring. Note:1 &lt;= S.length &lt;= 10^4All characters of S are lowercase English letters.1 &lt;= K &lt;= 10^4 题目大意：求一个字符串中有多少个长度为K的子字符串，要求没有重复的元素。 通过一个滑动窗口来扫描整个数组就可以得到答案，时间复杂度O（n) 12345678910111213141516171819class Solution: def numKLenSubstrNoRepeats(self, S: str, K: int) -&gt; int: if len(S) &lt; K: return 0 res = 0 dic = collections.Counter() l, r = 0, 0 while r &lt; len(S): dic[S[r]] += 1 if r - l + 1 &gt; K: dic[S[l]] -= 1 if dic[S[l]] == 0: del dic[S[l]] l += 1 if r - l + 1 == K: if len(dic) == K: res += 1 r += 1 return res LeetCode 1101 The Earliest Moment When Everyone Become Friends题目链接 12345678910111213141516171819202122232425262728293031323334In a social group, there are N people, with unique integer ids from 0 to N-1.We have a list of logs, where each logs[i] = [timestamp, id_A, id_B] contains a non-negative integer timestamp, and the ids of two different people.Each log represents the time in which two different people became friends. Friendship is symmetric: if A is friends with B, then B is friends with A.Let&apos;s say that person A is acquainted with person B if A is friends with B, or A is a friend of someone acquainted with B.Return the earliest time for which every person became acquainted with every other person. Return -1 if there is no such earliest time. Example 1:Input: logs = [[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],[20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]], N = 6Output: 20190301Explanation: The first event occurs at timestamp = 20190101 and after 0 and 1 become friends we have the following friendship groups [0,1], [2], [3], [4], [5].The second event occurs at timestamp = 20190104 and after 3 and 4 become friends we have the following friendship groups [0,1], [2], [3,4], [5].The third event occurs at timestamp = 20190107 and after 2 and 3 become friends we have the following friendship groups [0,1], [2,3,4], [5].The fourth event occurs at timestamp = 20190211 and after 1 and 5 become friends we have the following friendship groups [0,1,5], [2,3,4].The fifth event occurs at timestamp = 20190224 and as 2 and 4 are already friend anything happens.The sixth event occurs at timestamp = 20190301 and after 0 and 3 become friends we have that all become friends. Note:1 &lt;= N &lt;= 1001 &lt;= logs.length &lt;= 10^40 &lt;= logs[i][0] &lt;= 10^90 &lt;= logs[i][1], logs[i][2] &lt;= N - 1It&apos;s guaranteed that all timestamps in logs[i][0] are different.Logs are not necessarily ordered by some criteria.logs[i][1] != logs[i][2] 这个题目看上去很长，简单的来说就是一个朋友圈问题。一个数组里面有一些子数组，每个子数组第一个位置代表时间，第二个和第三个位置代表两个 不同的人。这两个人会在这个时间成为朋友，如果这两个人成为朋友，那么这两个人所处在的朋友圈里的所有人都将成为朋友，要求我们返回最小的时 间，使得所有人成为朋友。 这是一个比较典型的Union Find的问题，把每个人合并到一个圈子里，直到这个圈子包含了所有的人。Union Find的题目其实框架都是一样，在这 道题目中，当我们发现，两个人所处的朋友圈不一样时，我们需要合并这两个朋友圈，合并成功我们要从总人数中减去1，当count等于0的时候，说明 所有人都已经在一个朋友圈里了，这时候直接返回时间即可（需要对数组通过时间进行排序）。 123456789101112131415161718192021222324252627282930313233class Solution: def earliestAcq(self, logs: List[List[int]], N: int) -&gt; int: def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): px, py = find(x), find(y) if px == py: return else: if rank[px] == rank[py]: parent[py] = px rank[px] += rank[py] elif rank[px] &gt; rank[py]: parent[py] = px rank[px] += rank[py] elif rank[px] &lt; rank[py]: parent[px] = py rank[py] += rank[px] self.count -= 1 logs.sort() parent = [i for i in range(N)] rank = [1 for _ in range(N)] self.count = N - 1 res = 0 for log in logs: union(log[1], log[2]) if self.count == 0: return log[0] return -1 LeetCode 1102 Path With Maximum Minimum Value原题链接 1234567891011121314151617181920212223242526272829303132333435Given a matrix of integers A with R rows and C columns, find the maximum score of a path starting at [0,0] and ending at [R-1,C-1].The score of a path is the minimum value in that path. For example, the value of the path 8 → 4 → 5 → 9 is 4.A path moves some number of times from one visited cell to any neighbouring unvisited cell in one of the 4 cardinal directions (north, east, west, south). Example 1:Input: [[5,4,5],[1,2,6],[7,4,6]]Output: 4Explanation: The path with the maximum score is highlighted in yellow. Example 2:Input: [[2,2,1,2,2,2],[1,2,2,2,1,2]]Output: 2Example 3:Input: [[3,4,6,3,4],[0,2,1,1,7],[8,8,3,2,7],[3,2,4,9,8],[4,1,2,0,0],[4,6,5,4,3]]Output: 3 Note:1 &lt;= R, C &lt;= 1000 &lt;= A[i][j] &lt;= 10^9 这道题目不知道为啥通过率为啥这么低，可能好多人和我有一样的误解，大早上可能没睡醒。一开始我以为是找一条路径，从起点到终点，这条路径的 和是最大的，求路径中的最小值。（没仔细读题）看了案例感觉差不多，直接就开始写了，后来发现怎么都无法通过。重新审题，发现其实完全不是这 样。其实就是找一条路径，得到到这个路径中的最小值，使得这个值比其他路径中的最小值要大。 理解清楚后，可能很多人上来都会直接用深度优先搜索(DFS)来解决这个问题，这样做肯定是没问题的，但是在这道题目的数据规模和时间限制下是无 法AC的。粗略计算一下，每个点都有3个不同的方向，时间复杂度大约是O（(r * c) ** 3),时间复杂度非常高。仔细一想可以把这道题简化成找最大 值的问题，先上代码。 class Solution: def maximumMinimumPath(self, A: List[List[int]]) -&gt; int: heap = [(-A[0][0], 0, 0)] dp = [[0 for _ in range(len(A[0]))] for _ in range(len(A))] dp[0][0] = A[0][0] directions = [[1, 0], [-1, 0], [0, 1], [0, -1]] while heap: num, i, j = heapq.heappop(heap) val = -num for d in directions: newi, newj = i + d[0], j + d[1] if 0 &lt;= newi &lt; len(A) and 0 &lt;= newj &lt; len(A[0]): temp = min(val, A[newi][newj]) if temp &gt; dp[newi][newj]: dp[newi][newj] = temp heapq.heappush(heap,(-temp, newi, newj)) return dp[-1][-1] 首先需要建立一个堆数组，和一个dp矩阵，通过维护这个dp矩阵来找最终答案，也是为了优化时间复杂度。dp矩阵中每个元素代表的是不同路径到这个 点的时候，在路径中最小的最大值（好拗口。。）。找最大值这个过程其实就用堆排序来实现就可以，当然在python的自带的堆排序模块中，全部都是 最小堆（在之前的文章中提到过这个问题），要转换成最大堆，我们存入堆的元素需要取负即可。每一次操作如果这个位置的元素值不如dp数组中这个 位置的数值大，我们可以不在将其存入堆中，如果大于这个数字，我们需要将新的数字重新入堆，参与下一次循环。 总结这次的双周周赛感觉还是比较容易，但是自己在一些地方处理的不太好，导致有的地方速度很慢，也跟不熟练有关系，反应很慢。继续努力吧！Fight！]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 239 Sliding Window Maximum 滑动窗口最大值]]></title>
    <url>%2F2019%2F06%2F29%2Fwindow%2F</url>
    <content type="text"><![CDATA[LeetCode 239 Sliding Window Maximum 滑动窗口最大值原题链接 1234567891011121314151617181920Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the veryright. You can only see the k numbers in the window. Each time the sliding window moves right by one position.Return the max sliding window.Example:Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7Note: You may assume k is always valid, 1 ≤ k ≤ input array&apos;s size for non-empty array. 题目大意：给定一个固定size(k)的滑动窗口，当窗口滑动到不同位置时，存储当前窗口内的最大值。 这道题我第一眼看到的时候感觉这道题真的容易，完全不像一个hard的问题，直接上来就建立一个滑动窗口然后开始扫描整个数组，然后记录最大值， 当然了这个做法是没有任何问题的，但是这个问题在LeetCode里的测试案例的数据规模非常小，所以也能AC。 123456789#Brute forceclass Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: if not nums: return [] res = [] for i in range(len(nums) - k + 1): res.append(max(nums[i: i + k])) return res 上述的做法，时间复杂度是O（n * k),因为每次扫描，我们都需对当前窗口来计算最大值是多少，每一次调用max()方法，时间复杂度都是O（k)(窗 口的大小）。假设整个数组的长度非常大，窗口的尺寸也非常大，那么这个时间复杂度其实是O（n ** 2),效率就非常低了，所以我们需要对整个窗口 进行优化。 找最大值或者最小值，其实比较常规的方法就是堆排（Heap Sort），每次找最大值的时候时间复杂度为O(logn),避免每次都要重新扫描窗口。 1234567891011121314151617181920class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: res = [] if not nums: return res window = [] for i in range(k): heapq.heappush(window, -nums[i]) res.append(-window[0]) pop = collections.Counter() for i in range(k, len(nums)): out = nums[i - k] inn = nums[i] pop[out] += 1 heapq.heappush(window, -inn) while pop[-window[0]] &gt; 0: pop[-window[0]] -= 1 heapq.heappop(window) res.append(-window[0]) return res 还有一种更快捷的方法，用队列来解决这个问题，其实这个问题可以简化成维护一个队列，我们只需要知道当前的最大值是多少，还有当前最大值是不 是在这个窗口里，其他的事情其实都不需要考虑，这样一来时间复杂度可以简化到O（n）。 12345678910111213class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: window = collections.deque() res = [] for i, num in enumerate(nums): while window and num &gt; nums[window[-1]]: window.pop() window.append(i) if i &gt;= k - 1: res.append(nums[window[0]]) if i - k + 1 == window[0]: window.popleft() return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>滑动窗口（Sliding Window）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 72 Edit Distance 编辑距离]]></title>
    <url>%2F2019%2F06%2F27%2Fdistance%2F</url>
    <content type="text"><![CDATA[LeetCode 72 Edit Distance原题链接 123456789101112131415161718192021222324252627Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.You have the following 3 operations permitted on a word:Insert a characterDelete a characterReplace a characterExample 1:Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)rorse -&gt; rose (remove &apos;r&apos;)rose -&gt; ros (remove &apos;e&apos;)Example 2:Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &apos;t&apos;)inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;)enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;)exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;)exection -&gt; execution (insert &apos;u&apos;) 题目大意，将word1变成word2，最少需要多少步骤。一般碰到这种问题，尽量不要想着用Brute Force的方法去解决，因为如果想通过找出所有可能 的单词，来计算最少步骤数目，时间复杂度是非常高的，因为一个位置可以替换26个字母或者添加或删除一个字母，时间复杂度是指数增长的。所以这 种时候需要通过动态规划来解决这个问题。动态规划的本质是通过一个小的问题来解决较大规模的问题。但是如何找到转移方程，是DP类问题的关键， 也是解决DP问题最难的地方。有的时候知道这个问题需要用DP来解决，但是却无从下手，这种情况非常正常，其实个人认为在LeetCode中最难的一部 分问题就是DP了，只能通过更多的练习来强化。 这个问题是一道Hard的题目，但是代码非常短，像一个easy的题目，但是这其中需要思考的问题很多，以及如何去理解这个题目中DP的意义。先上 代码！ 1234567891011121314class Solution: def minDistance(self, word1: str, word2: str) -&gt; int: dp = [[0 for _ in range(len(word1) + 1)] for _ in range(len(word2) + 1)] for i in range(1, len(dp)): dp[i][0] = i for i in range(1, len(dp[0])): dp[0][i] = i for i in range(1, len(dp)): for j in range(1, len(dp[0])): if word1[j - 1] == word2[i - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1 return dp[-1][-1] 首先构建一个DP的二维矩阵，如果练习的够多可以总结出，要解决对比两个字符串的问题，基本都是可以基于一个二维的DP数组来解决。首先来解释一 下dp[i][j]的含义。dp[i][j]代表的是word1[:j]变成word2[:i]需要多少步，而且dp[i][j]只和dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]有关，也就是说，和最近的三个子问题有关。现在的问题是这三个子问题都代表什么，如何实现通过dp来实现，insert, remove, replace的操作。我简单的通过几个简单的例子来解释。 123456789101112131415remove:word1 = &quot;ab&quot;, word2 = &quot;a&quot;这个可以比较容易的看出，如果想把word1变成word2最快的方法就是将word1末尾的&quot;b&quot;删除掉。dp[i][j] = dp[i][j - 1] + 1dp[i][j - 1]是word1 = &quot;a&quot; word2 = &quot;a&quot;的时候，因为要移除&quot;b&quot;,所以要多一次操作。insert:word1 = &quot;a&quot;, word2 = &quot;ab&quot;这个例子中，需要在word1中添加一个&quot;b&quot;才能和word2一样。dp[i][j] = dp[i - 1][j] + 1replace:word1 = &quot;ab&quot;, word2 = &quot;ac&quot;将word1中的&quot;b&quot;替换成&quot;c&quot;，也就是说需要从两个字符串都是&quot;a&quot;的状态来替换(dp[i - 1][j - 1])dp[i][j] = dp[i - 1][j - 1] + 1 这样如何完成这三种操作的方法已经介绍完了，这道题还有一个要点，就是要初始化dp，因为不初始化dp的话，所有位置的起始状态都是0，这是不对 的，因为我们的最初状态是从两个空的字符串开始的，然后逐渐往后延伸，所以每一个字符串要想变成空字符串的话，也就是当前位置的数字等于当前 字符串的长度。 123456Initialize:dp = [[0 for _ in range(len(word1) + 1)] for _ in range(len(word2) + 1)] for i in range(1, len(dp)): dp[i][0] = i for i in range(1, len(dp[0])): dp[0][i] = i 最后返回dp[-1][-1]就是最小的步数。]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 924 Minimize Malware Spread 最大限度减少恶意软件传播]]></title>
    <url>%2F2019%2F06%2F26%2FSpread%2F</url>
    <content type="text"><![CDATA[LeetCode 924 Minimize Malware Spread原题链接 这道题是LeetCode中属于hard难度的题目，也是一道高频题，个人认为这道题是一道非常典型的题目。题目很长，大概意思就是，有一些节点，其中 一些节点被病毒感染了，某一些节点之间是相互连接的（形成一个图），如果这个图中有一个节点是被病毒感染的，那么整个图都会被感染。要求我们 找到其中一个被感染的节点，并删除他，使所有节点受感染的数目最少。 例子 1234567891011121314151617181920212223Example 1:Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]Output: 00---120和1构成一个图， 2不和任何节点连接，由于0和1同时都被病毒感染，所以按照题目要求我们需要返回一个较小数字的节点。Example 2:Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]Output: 0例子2和例子1其实是类似的。Example 3:Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]Output: 1 0 -- 1 \ / 2这三个节点彼此相互连接， 所以仍然是返回哪个比较小的被感染节点。 其实通过上述三个例子，不是很容易弄明白这个问题。如果在一个图中，有至少有两个以上的节点是被病毒感染的，那么其实无论删除哪个，都不能避 免整个图被感染。所以在扫描整个图时，如果存在这么一个图，图中只有一个节点是被感染的，那么我们如果删除这个节点就可以使这一部分的图，全 变成正常情况。依照这个原则去搜索，即可找出答案。 首先我们需要构造这个图，构图这部分我喜欢写在Union Find的类里面，然后在主函数中进行搜索就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class UnionFind: def __init__(self, graph): self.parent = [i for i in range(len(graph))] self.rank = [1 for _ in range(len(graph))] for i in range(len(graph)): for j in range(i + 1, len(graph[0])): if graph[i][j] == 1 and i != j: self.union(i, j) def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): px, py = self.find(x), self.find(y) if px == py: return if self.rank[px] == self.rank[py]: self.parent[py] = px self.rank[px] += self.rank[py] else: if self.rank[px] &gt; self.rank[py]: self.parent[py] = px self.rank[px] += self.rank[py] else: self.parent[px] = py self.rank[py] += self.rank[px]#上面这个class是UnionFind和图的构造过程，UnionFind在寻找每个节点的父亲节点的平均用时是O（1），所以这个结构对于构造一个图来说是非常高效的。class Solution: def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -&gt; int: uf = UnionFind(graph) dic = collections.defaultdict(list) for i, e in enumerate(uf.parent): dic[e].append(i) #用字典来保存每一个图 res = min(initial) #如果找不到更优的结果，我们需要返回最小值 initial = set(initial) #将病毒节点数组转换成集合，方便搜索（集合中搜索元素的时间复杂度是O（1） mincount = 0 for node in dic: seen = set() for n in dic[node]: if n in initial: seen.add(n) #找出图中所有被感染的节点 if len(seen) == 1: #判断该删除哪个节点 if len(dic[node]) &gt; mincount or (len(dic[node]) == mincount and list(seen)[0] &lt; res): res = list(seen)[0] mincount = len(dic[node]) return res 如果想避免构图这个过程，这道题可以直接用深度优先搜索来求解，深度优先搜索(DFS)的代码更加简洁，但是Union Find的代码看上去更加直观。 1234567891011121314151617181920212223#DFSclass Solution: def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -&gt; int: def dfs(node,vis): for v in range(len(graph[node])): if graph[node][v] == 1 and v not in vis: vis.add(v) dfs(v,vis) seen = set() res = min(initial) initial = set(initial) mincount = 0 for node in range(len(graph)): if node not in seen: vis = set([node]) dfs(node,vis) infect = vis &amp; initial if len(infect) == 1: if len(vis) &gt; mincount or (len(vis) == mincount and list(infect)[0] &lt; res): res = list(infect)[0] mincount = len(vis) seen |= vis return res]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>高频</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 215 Kth Largest Element in an Array 排序算法总结]]></title>
    <url>%2F2019%2F06%2F25%2F215%2F</url>
    <content type="text"><![CDATA[LeetCode 215 Kth Largest Element in an Array原题链接 题目大意：从一个未排序的数组中找到第K大的元素。 其实想单纯的解决这个问题真的是非常容易，在Python中一行代码就可以解决。 One - line12def findKthLargest1(self, nums, k): return sorted(nums, reverse = True)[k - 1] 在Python中，sort()方法的时间复杂度是O(nlogn),其实看到第K个元素问题，第一时间想到方法应该是堆排序（Heap Sort), 每一次pop出一个 元素，循环K次即可找到答案。 Heap Sort在这里堆排序可以节省很多时间，但是这里存在着到底是用最大堆(Max heap)还是最小堆(Min Heap)的问题。在Python中，heap模块自动生成的是 最小堆，如果想生成一个最大堆，我们需要将数组中所有的数字取负数，然后重新堆化(Heapify)。那么两者的时间复杂度为 O(n + xlogn), 为什么我这里使用了x， 其实到底是最小堆快还是最大堆快，取决于k到底是靠近数组的开始，还是靠近数组的结尾。如果K在数组的 中间位置，那么两者的时间复杂度其实几乎是一样的。如果K靠近起始位置，那么肯定Min Heap会快，反之亦然。 Min Heap1234567class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: heapq.heapify(nums) res = 0 for _ in range(len(nums) - k + 1): res = heapq.heappop(nums) return res Max Heap12345678class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: heap = [-num for num in nums] heapq.heapify(heap) res = 0 for _ in range(k): res = -heapq.heappop(heap) return res 排序算法(Python 版本)其实这道题考察的是到底该使用那种排序算法，我简单的对几种常用的排序算法进行一下总结。 冒泡排序(Bubble Sort)冒牌排序的本质其实是针对相邻元素，如果第一个元素比第二个元素大，那么交换两者的位置，重复上述的步骤，直到没有可以交换的元素。 平均时间复杂度：O(n ** 2) 最坏时间复杂度：O(n ** 2) 最好时间复杂度：O(n) 空间复杂度： O(1) in-place 123456def BubbleSort(nums): for i in range(1, len(nums)): for j in range(len(nums) - i): if nums[j] &gt; nums[j + 1]: nums[j], nums[j + 1] = nums[j + 1], nums[j] return nums 选择排序(Selection Sort)在未排序数组中找到最大（小）的元素，放在每一轮起始的位置，每一轮结束后，接下来在剩余的数组中继续操作。 平均时间复杂度：O（n ** 2) 最好时间复杂度：O（n ** 2) 最坏时间复杂度：O（n ** 2) 空间复杂度： O（1） in - place 123456789def SelectionSort(nums): for i in range(len(nums) - 1): index = i for j in range(i + 1, len(nums)): if nums[j] &lt; nums[index]: index = j if index != i: nums[index], nums[i] = nums[i], nums[index] return nums 插入排序（Insertion Sort）扫描整个数组，然后针对这个位置上的数字进行操作，如果这个数字比前面的数字小，就一直往前移动，直到整个数组没有可以操作的元素。 平均时间复杂度：O（n ** 2) 最好时间复杂度：O（n) 最坏时间复杂度：O（n ** 2） 空间复杂度： O（1） in - place 123456789def InsertionSort(nums): for i in range(len(nums)): pre = i - 1 cur = nums[i] while pre &gt;= 0 and arr[pre] &gt; cur: arr[pre + 1] = arr[pre] pre -= 1 arr[pre + 1] = cur return nums 希尔排序(Shell Sort)希尔排序法(缩小增量法) 属于插入类排序，是将整个无序列分割成若干小的子序列分别进行插入排序的方法。 平均时间复杂度：O（nlogn) 最好时间复杂度：O（n） 最坏时间复杂度：O（n ** 2） 空间复杂度：O（1）in - place 1234567891011121314def ShellSort(nums): gap = 1 while gap &lt; len(nums) // 2: gap = gap * 3 + 1 while gap &gt; 0: for i in range(gap, len(nums)): temp = nums[i] j = i - gap while j &gt;= 0 and nums[j] &gt; temp: nums[j + gap] = nums[j] j -= gap nums[j + gap] = temp gap = gap // 3 return nums 归并排序(Merge Sort)将一个完整的数组拆分成一些子序列，然后分别针对子序列进行排序，最后在合并到一起，Divide and Conquer的思想。 时间复杂度：O(nlogn) 空间复杂度：O（n） 12345678910111213141516171819202122def MergeSort(nums): if len(nums) &lt; 2: return nums mid = len(nums) // 2 return merge(MergeSort(nums[:mid]), MergeSort(nums[mid:]))def merge(l, r): nums = [] a, b = 0, 0 while a &lt; len(l) and b &lt; len(r): if l[a] &lt; r[b]: nums.append(l[a]) a += 1 else: nums.append(r[b]) b += 1 if a &lt; len(l): nums += l[a:] if b &lt; len(r): nums += r[b:] return nums 快速排序(Quick Sort)找到一个轴，比这个轴大的数字放在一个数组，比轴小的数字放在另一个数组，然后用递归加分而治之对子数组进行相同的操作，最后合并所有子数组。 平均时间复杂度：O（nlogn） 最好时间复杂度：O（nlogn） 最坏时间复杂度：O（n ** 2) 空间复杂度： O（nlogn） 12345678910111213def QuickSort(nums): if len(nums) &lt; 2: return nums else: mid = nums[len(nums) // 2] left = [] right = [] for num in nums: if num &gt; mid: right.append(num) else: left.append(num) return QuickSort(left) + [mid] + QuickSort(right)]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 79, 212 Word Search]]></title>
    <url>%2F2019%2F06%2F24%2FWordSearch%2F</url>
    <content type="text"><![CDATA[LeetCode 79 Word Search原题链接 题目大意：给定一个二维的网格和一个单词，判断单词是否在网格中。 单词必须按照字母顺序，通过相邻的单元格的字母组成，其中相邻指的是4个方向（上，下，左，右），同一个单元格中的单词不能重复使用。 例子12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false. 这道题目，只需要查找一个单词，所以直接暴力求解(bracktrack)就可以。遍历二维网格，找到一个符合要求的开头（单词的首字母），然后以这个 点为起点，进行回溯。 123456789101112131415161718192021222324class Solution: def exist(self, board: List[List[str]], word: str) -&gt; bool: for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == word[0]: if self.dfs(board, i, j, 0, word): return True return False def dfs(self, board, i, j, index, word): if index == len(word): return True if i &lt; 0 or i &gt;= len(board) or j &lt; 0 or j &gt;= len(board[0]) or board[i][j] != word[index]: return False board[i][j] = &apos;#&apos; if self.dfs(board, i - 1, j, index + 1, word): return True if self.dfs(board, i + 1, j, index + 1, word): return True if self.dfs(board, i, j - 1, index + 1, word): return True if self.dfs(board, i , j + 1, index + 1, word): return True board[i][j] = word[index] #LeetCode 212 Word Search II 原题链接12345678910Input: board = [ [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;], [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;], [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;], [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]]words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]Output: [&quot;eat&quot;,&quot;oath&quot;] 这道题其实是Word Search 的升级版，区别在于，前者只要求查找一个单词，后者需要从一个数组中查找每一个单词。我们不可以再像第一题这样直 接进行暴力求解。需要先对整个数组进行预处理。需要使用一个特殊的数据结构叫做字典树（Trie）。在Python中，如果想从一个字典中搜索一个元 素，时间复杂度为O(1),这样可以大大减少我们在搜索中所用的时间。 1&#123;&apos;o&apos;: &#123;&apos;a&apos;: &#123;&apos;t&apos;: &#123;&apos;h&apos;: &#123;&apos;end&apos;: &apos;#&apos;&#125;&#125;&#125;&#125;, &apos;p&apos;: &#123;&apos;e&apos;: &#123;&apos;a&apos;: &#123;&apos;end&apos;: &apos;#&apos;&#125;&#125;&#125;, &apos;e&apos;: &#123;&apos;a&apos;: &#123;&apos;t&apos;: &#123;&apos;end&apos;: &apos;#&apos;&#125;&#125;&#125;, &apos;r&apos;: &#123;&apos;a&apos;: &#123;&apos;i&apos;: &#123;&apos;n&apos;: &#123;&apos;end&apos;: &apos;#&apos;&#125;&#125;&#125;&#125;&#125; 对于整个数组预处理过后，字典树如上图，一定要注意用一个标志（&quot;end&quot;)来表明一个完整单词的结束。否则我们无法确定这是一个完整的单词，还是 一个单词的一部分。 backtrack的过程和上一题的过程累似，只不过需要不断更新root（当前字母作为根节点），然后进行搜索，直到结束。 12345678910111213141516171819202122232425262728class Solution: def findWords(self, board: List[List[str]], words: List[str]) -&gt; List[str]: dic = &#123;&#125; self.res = set() for word in words: node = dic for char in word: if char not in node: node[char] = &#123;&#125; node = node[char] node[&apos;end&apos;] = &apos;#&apos; for i in range(len(board)): for j in range(len(board[0])): self.dfs(dic, board, i, j, &quot;&quot;) return list(self.res) def dfs(self, node, board, i, j, path): if &apos;end&apos; in node: self.res.add(path) if i &lt; 0 or i &gt;= len(board) or j &lt; 0 or j &gt;= len(board[0]) or board[i][j] not in node: return temp = board[i][j] board[i][j] = &apos;#&apos; self.dfs(node[temp], board, i - 1, j, path + temp) self.dfs(node[temp], board, i + 1, j, path + temp) self.dfs(node[temp], board, i, j - 1, path + temp) self.dfs(node[temp], board, i, j + 1, path + temp) board[i][j] = temp]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>高频</tag>
        <tag>BackTrack</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于刷题]]></title>
    <url>%2F2019%2F06%2F23%2FLeetCode%2F</url>
    <content type="text"><![CDATA[LeetCode关于刷题 在现在的大环境下，刷题似乎成为了大部分人的必经之路，越来越多的公司在面试中通过相关题目，来考察求职者。就算已经找到工作的人，也 有很多人每天保持着练习，为了防止自己手生。其实无论到底出于什么目的，刷题真的很重要，当然，刷题不一定能确保你找到一份好的工作，但是 不刷题感觉基本没有设么机会。作为一个转专业的选手（从硬件到软件），这段经历真的是挺痛苦的，刚开始刷题的时候什么都不会，到坚持了6个 月， 刷了900道题，将近4500个submission。这段路真的非常艰辛，但是一定要咬着牙走下去。 看着上面的图，稍微有一点点成就感，但是更多的感觉到一点点忧伤，因为真的感觉好辛苦好累。做这个博客，一个想记录一下自己刷题的生 活，顺便把一些重点的题目的思路重新理一下，并分享给需要的人。我用的是Python（别问， 人生苦短，我用？？？？），以后有机会会试着用 Java写一写。]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
